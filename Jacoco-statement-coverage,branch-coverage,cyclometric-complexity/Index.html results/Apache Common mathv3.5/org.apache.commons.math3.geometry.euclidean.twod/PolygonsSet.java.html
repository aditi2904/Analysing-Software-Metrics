<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PolygonsSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.geometry.euclidean.twod</a> &gt; <span class="el_source">PolygonsSet.java</span></div><h1>PolygonsSet.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math3.geometry.euclidean.twod;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.commons.math3.geometry.Point;
import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D;
import org.apache.commons.math3.geometry.euclidean.oned.Interval;
import org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet;
import org.apache.commons.math3.geometry.euclidean.oned.Vector1D;
import org.apache.commons.math3.geometry.partitioning.AbstractRegion;
import org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane;
import org.apache.commons.math3.geometry.partitioning.BSPTree;
import org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor;
import org.apache.commons.math3.geometry.partitioning.BoundaryAttribute;
import org.apache.commons.math3.geometry.partitioning.Hyperplane;
import org.apache.commons.math3.geometry.partitioning.Side;
import org.apache.commons.math3.geometry.partitioning.SubHyperplane;
import org.apache.commons.math3.util.FastMath;
import org.apache.commons.math3.util.Precision;

/** This class represents a 2D region: a set of polygons.
 * @since 3.0
 */
public class PolygonsSet extends AbstractRegion&lt;Euclidean2D, Euclidean1D&gt; {

    /** Default value for tolerance. */
    private static final double DEFAULT_TOLERANCE = 1.0e-10;

    /** Vertices organized as boundary loops. */
    private Vector2D[][] vertices;

    /** Build a polygons set representing the whole plane.
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final double tolerance) {
<span class="fc" id="L55">        super(tolerance);</span>
<span class="fc" id="L56">    }</span>

    /** Build a polygons set from a BSP tree.
     * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a
     * {@code Boolean} attribute representing the inside status of
     * the corresponding cell (true for inside cells, false for outside
     * cells). In order to avoid building too many small objects, it is
     * recommended to use the predefined constants
     * {@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;
     * &lt;p&gt;
     * This constructor is aimed at expert use, as building the tree may
     * be a difficult task. It is not intended for general use and for
     * performances reasons does not check thoroughly its input, as this would
     * require walking the full tree each time. Failing to provide a tree with
     * the proper attributes, &lt;em&gt;will&lt;/em&gt; therefore generate problems like
     * {@link NullPointerException} or {@link ClassCastException} only later on.
     * This limitation is known and explains why this constructor is for expert
     * use only. The caller does have the responsibility to provided correct arguments.
     * &lt;/p&gt;
     * @param tree inside/outside BSP tree representing the region
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final BSPTree&lt;Euclidean2D&gt; tree, final double tolerance) {
<span class="fc" id="L80">        super(tree, tolerance);</span>
<span class="fc" id="L81">    }</span>

    /** Build a polygons set from a Boundary REPresentation (B-rep).
     * &lt;p&gt;The boundary is provided as a collection of {@link
     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
     * interior part of the region on its minus side and the exterior on
     * its plus side.&lt;/p&gt;
     * &lt;p&gt;The boundary elements can be in any order, and can form
     * several non-connected sets (like for example polygons with holes
     * or a set of disjoint polygons considered as a whole). In
     * fact, the elements do not even need to be connected together
     * (their topological connections are not used here). However, if the
     * boundary does not really separate an inside open from an outside
     * open (open having here its topological meaning), then subsequent
     * calls to the {@link
     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point)
     * checkPoint} method will not be meaningful anymore.&lt;/p&gt;
     * &lt;p&gt;If the boundary is empty, the region will represent the whole
     * space.&lt;/p&gt;
     * @param boundary collection of boundary elements, as a
     * collection of {@link SubHyperplane SubHyperplane} objects
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final Collection&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundary, final double tolerance) {
<span class="fc" id="L106">        super(boundary, tolerance);</span>
<span class="fc" id="L107">    }</span>

    /** Build a parallellepipedic box.
     * @param xMin low bound along the x direction
     * @param xMax high bound along the x direction
     * @param yMin low bound along the y direction
     * @param yMax high bound along the y direction
     * @param tolerance tolerance below which points are considered identical
     * @since 3.3
     */
    public PolygonsSet(final double xMin, final double xMax,
                       final double yMin, final double yMax,
                       final double tolerance) {
<span class="fc" id="L120">        super(boxBoundary(xMin, xMax, yMin, yMax, tolerance), tolerance);</span>
<span class="fc" id="L121">    }</span>

    /** Build a polygon from a simple list of vertices.
     * &lt;p&gt;The boundary is provided as a list of points considering to
     * represent the vertices of a simple loop. The interior part of the
     * region is on the left side of this path and the exterior is on its
     * right side.&lt;/p&gt;
     * &lt;p&gt;This constructor does not handle polygons with a boundary
     * forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
     * &lt;p&gt;For cases where this simple constructor applies, it is expected to
     * be numerically more robust than the {@link #PolygonsSet(Collection) general
     * constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;
     * &lt;p&gt;If the list is empty, the region will represent the whole
     * space.&lt;/p&gt;
     * &lt;p&gt;
     * Polygons with thin pikes or dents are inherently difficult to handle because
     * they involve lines with almost opposite directions at some vertices. Polygons
     * whose vertices come from some physical measurement with noise are also
     * difficult because an edge that should be straight may be broken in lots of
     * different pieces with almost equal directions. In both cases, computing the
     * lines intersections is not numerically robust due to the almost 0 or almost
     * &amp;pi; angle. Such cases need to carefully adjust the {@code hyperplaneThickness}
     * parameter. A too small value would often lead to completely wrong polygons
     * with large area wrongly identified as inside or outside. Large values are
     * often much safer. As a rule of thumb, a value slightly below the size of the
     * most accurate detail needed is a good value for the {@code hyperplaneThickness}
     * parameter.
     * &lt;/p&gt;
     * @param hyperplaneThickness tolerance below which points are considered to
     * belong to the hyperplane (which is therefore more a slab)
     * @param vertices vertices of the simple loop boundary
     */
    public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices) {
<span class="fc" id="L154">        super(verticesToTree(hyperplaneThickness, vertices), hyperplaneThickness);</span>
<span class="fc" id="L155">    }</span>

    /** Build a polygons set representing the whole real line.
     * @deprecated as of 3.3, replaced with {@link #PolygonsSet(double)}
     */
    @Deprecated
    public PolygonsSet() {
<span class="nc" id="L162">        this(DEFAULT_TOLERANCE);</span>
<span class="nc" id="L163">    }</span>

    /** Build a polygons set from a BSP tree.
     * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a
     * {@code Boolean} attribute representing the inside status of
     * the corresponding cell (true for inside cells, false for outside
     * cells). In order to avoid building too many small objects, it is
     * recommended to use the predefined constants
     * {@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;
     * @param tree inside/outside BSP tree representing the region
     * @deprecated as of 3.3, replaced with {@link #PolygonsSet(BSPTree, double)}
     */
    @Deprecated
    public PolygonsSet(final BSPTree&lt;Euclidean2D&gt; tree) {
<span class="nc" id="L177">        this(tree, DEFAULT_TOLERANCE);</span>
<span class="nc" id="L178">    }</span>

    /** Build a polygons set from a Boundary REPresentation (B-rep).
     * &lt;p&gt;The boundary is provided as a collection of {@link
     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
     * interior part of the region on its minus side and the exterior on
     * its plus side.&lt;/p&gt;
     * &lt;p&gt;The boundary elements can be in any order, and can form
     * several non-connected sets (like for example polygons with holes
     * or a set of disjoint polygons considered as a whole). In
     * fact, the elements do not even need to be connected together
     * (their topological connections are not used here). However, if the
     * boundary does not really separate an inside open from an outside
     * open (open having here its topological meaning), then subsequent
     * calls to the {@link
     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point)
     * checkPoint} method will not be meaningful anymore.&lt;/p&gt;
     * &lt;p&gt;If the boundary is empty, the region will represent the whole
     * space.&lt;/p&gt;
     * @param boundary collection of boundary elements, as a
     * collection of {@link SubHyperplane SubHyperplane} objects
     * @deprecated as of 3.3, replaced with {@link #PolygonsSet(Collection, double)}
     */
    @Deprecated
    public PolygonsSet(final Collection&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundary) {
<span class="nc" id="L203">        this(boundary, DEFAULT_TOLERANCE);</span>
<span class="nc" id="L204">    }</span>

    /** Build a parallellepipedic box.
     * @param xMin low bound along the x direction
     * @param xMax high bound along the x direction
     * @param yMin low bound along the y direction
     * @param yMax high bound along the y direction
     * @deprecated as of 3.3, replaced with {@link #PolygonsSet(double, double, double, double, double)}
     */
    @Deprecated
    public PolygonsSet(final double xMin, final double xMax,
                       final double yMin, final double yMax) {
<span class="nc" id="L216">        this(xMin, xMax, yMin, yMax, DEFAULT_TOLERANCE);</span>
<span class="nc" id="L217">    }</span>

    /** Create a list of hyperplanes representing the boundary of a box.
     * @param xMin low bound along the x direction
     * @param xMax high bound along the x direction
     * @param yMin low bound along the y direction
     * @param yMax high bound along the y direction
     * @param tolerance tolerance below which points are considered identical
     * @return boundary of the box
     */
    private static Line[] boxBoundary(final double xMin, final double xMax,
                                      final double yMin, final double yMax,
                                      final double tolerance) {
<span class="pc bpc" id="L230" title="1 of 4 branches missed.">        if ((xMin &gt;= xMax - tolerance) || (yMin &gt;= yMax - tolerance)) {</span>
            // too thin box, build an empty polygons set
<span class="fc" id="L232">            return null;</span>
        }
<span class="fc" id="L234">        final Vector2D minMin = new Vector2D(xMin, yMin);</span>
<span class="fc" id="L235">        final Vector2D minMax = new Vector2D(xMin, yMax);</span>
<span class="fc" id="L236">        final Vector2D maxMin = new Vector2D(xMax, yMin);</span>
<span class="fc" id="L237">        final Vector2D maxMax = new Vector2D(xMax, yMax);</span>
<span class="fc" id="L238">        return new Line[] {</span>
<span class="fc" id="L239">            new Line(minMin, maxMin, tolerance),</span>
<span class="fc" id="L240">            new Line(maxMin, maxMax, tolerance),</span>
<span class="fc" id="L241">            new Line(maxMax, minMax, tolerance),</span>
<span class="fc" id="L242">            new Line(minMax, minMin, tolerance)</span>
        };
    }

    /** Build the BSP tree of a polygons set from a simple list of vertices.
     * &lt;p&gt;The boundary is provided as a list of points considering to
     * represent the vertices of a simple loop. The interior part of the
     * region is on the left side of this path and the exterior is on its
     * right side.&lt;/p&gt;
     * &lt;p&gt;This constructor does not handle polygons with a boundary
     * forming several disconnected paths (such as polygons with holes).&lt;/p&gt;
     * &lt;p&gt;For cases where this simple constructor applies, it is expected to
     * be numerically more robust than the {@link #PolygonsSet(Collection) general
     * constructor} using {@link SubHyperplane subhyperplanes}.&lt;/p&gt;
     * @param hyperplaneThickness tolerance below which points are consider to
     * belong to the hyperplane (which is therefore more a slab)
     * @param vertices vertices of the simple loop boundary
     * @return the BSP tree of the input vertices
     */
    private static BSPTree&lt;Euclidean2D&gt; verticesToTree(final double hyperplaneThickness,
                                                       final Vector2D ... vertices) {

<span class="fc" id="L264">        final int n = vertices.length;</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (n == 0) {</span>
            // the tree represents the whole space
<span class="nc" id="L267">            return new BSPTree&lt;Euclidean2D&gt;(Boolean.TRUE);</span>
        }

        // build the vertices
<span class="fc" id="L271">        final Vertex[] vArray = new Vertex[n];</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L273">            vArray[i] = new Vertex(vertices[i]);</span>
        }

        // build the edges
<span class="fc" id="L277">        List&lt;Edge&gt; edges = new ArrayList&lt;Edge&gt;(n);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>

            // get the endpoints of the edge
<span class="fc" id="L281">            final Vertex start = vArray[i];</span>
<span class="fc" id="L282">            final Vertex end   = vArray[(i + 1) % n];</span>

            // get the line supporting the edge, taking care not to recreate it
            // if it was already created earlier due to another edge being aligned
            // with the current one
<span class="fc" id="L287">            Line line = start.sharedLineWith(end);</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            if (line == null) {</span>
<span class="fc" id="L289">                line = new Line(start.getLocation(), end.getLocation(), hyperplaneThickness);</span>
            }

            // create the edge and store it
<span class="fc" id="L293">            edges.add(new Edge(start, end, line));</span>

            // check if another vertex also happens to be on this line
<span class="fc bfc" id="L296" title="All 2 branches covered.">            for (final Vertex vertex : vArray) {</span>
<span class="fc bfc" id="L297" title="All 4 branches covered.">                if (vertex != start &amp;&amp; vertex != end &amp;&amp;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">                    FastMath.abs(line.getOffset((Point&lt;Euclidean2D&gt;) vertex.getLocation())) &lt;= hyperplaneThickness) {</span>
<span class="fc" id="L299">                    vertex.bindWith(line);</span>
                }
            }

        }

        // build the tree top-down
<span class="fc" id="L306">        final BSPTree&lt;Euclidean2D&gt; tree = new BSPTree&lt;Euclidean2D&gt;();</span>
<span class="fc" id="L307">        insertEdges(hyperplaneThickness, tree, edges);</span>

<span class="fc" id="L309">        return tree;</span>

    }

    /** Recursively build a tree by inserting cut sub-hyperplanes.
     * @param hyperplaneThickness tolerance below which points are consider to
     * belong to the hyperplane (which is therefore more a slab)
     * @param node current tree node (it is a leaf node at the beginning
     * of the call)
     * @param edges list of edges to insert in the cell defined by this node
     * (excluding edges not belonging to the cell defined by this node)
     */
    private static void insertEdges(final double hyperplaneThickness,
                                    final BSPTree&lt;Euclidean2D&gt; node,
                                    final List&lt;Edge&gt; edges) {

        // find an edge with an hyperplane that can be inserted in the node
<span class="fc" id="L326">        int index = 0;</span>
<span class="fc" id="L327">        Edge inserted =null;</span>
<span class="pc bpc" id="L328" title="1 of 4 branches missed.">        while (inserted == null &amp;&amp; index &lt; edges.size()) {</span>
<span class="fc" id="L329">            inserted = edges.get(index++);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (inserted.getNode() == null) {</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">                if (node.insertCut(inserted.getLine())) {</span>
<span class="fc" id="L332">                    inserted.setNode(node);</span>
<span class="fc" id="L333">                } else {</span>
<span class="nc" id="L334">                    inserted = null;</span>
                }
<span class="nc" id="L336">            } else {</span>
<span class="nc" id="L337">                inserted = null;</span>
            }
        }

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (inserted == null) {</span>
            // no suitable edge was found, the node remains a leaf node
            // we need to set its inside/outside boolean indicator
<span class="nc" id="L344">            final BSPTree&lt;Euclidean2D&gt; parent = node.getParent();</span>
<span class="nc bnc" id="L345" title="All 4 branches missed.">            if (parent == null || node == parent.getMinus()) {</span>
<span class="nc" id="L346">                node.setAttribute(Boolean.TRUE);</span>
<span class="nc" id="L347">            } else {</span>
<span class="nc" id="L348">                node.setAttribute(Boolean.FALSE);</span>
            }
<span class="nc" id="L350">            return;</span>
        }

        // we have split the node by inserting an edge as a cut sub-hyperplane
        // distribute the remaining edges in the two sub-trees
<span class="fc" id="L355">        final List&lt;Edge&gt; plusList  = new ArrayList&lt;Edge&gt;();</span>
<span class="fc" id="L356">        final List&lt;Edge&gt; minusList = new ArrayList&lt;Edge&gt;();</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        for (final Edge edge : edges) {</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">            if (edge != inserted) {</span>
<span class="fc" id="L359">                final double startOffset = inserted.getLine().getOffset((Point&lt;Euclidean2D&gt;) edge.getStart().getLocation());</span>
<span class="fc" id="L360">                final double endOffset   = inserted.getLine().getOffset((Point&lt;Euclidean2D&gt;) edge.getEnd().getLocation());</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                Side startSide = (FastMath.abs(startOffset) &lt;= hyperplaneThickness) ?</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">                                 Side.HYPER : ((startOffset &lt; 0) ? Side.MINUS : Side.PLUS);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">                Side endSide   = (FastMath.abs(endOffset) &lt;= hyperplaneThickness) ?</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">                                 Side.HYPER : ((endOffset &lt; 0) ? Side.MINUS : Side.PLUS);</span>
<span class="fc bfc" id="L365" title="All 3 branches covered.">                switch (startSide) {</span>
                    case PLUS:
<span class="fc bfc" id="L367" title="All 2 branches covered.">                        if (endSide == Side.MINUS) {</span>
                            // we need to insert a split point on the hyperplane
<span class="fc" id="L369">                            final Vertex splitPoint = edge.split(inserted.getLine());</span>
<span class="fc" id="L370">                            minusList.add(splitPoint.getOutgoing());</span>
<span class="fc" id="L371">                            plusList.add(splitPoint.getIncoming());</span>
<span class="fc" id="L372">                        } else {</span>
<span class="fc" id="L373">                            plusList.add(edge);</span>
                        }
<span class="fc" id="L375">                        break;</span>
                    case MINUS:
<span class="fc bfc" id="L377" title="All 2 branches covered.">                        if (endSide == Side.PLUS) {</span>
                            // we need to insert a split point on the hyperplane
<span class="fc" id="L379">                            final Vertex splitPoint = edge.split(inserted.getLine());</span>
<span class="fc" id="L380">                            minusList.add(splitPoint.getIncoming());</span>
<span class="fc" id="L381">                            plusList.add(splitPoint.getOutgoing());</span>
<span class="fc" id="L382">                        } else {</span>
<span class="fc" id="L383">                            minusList.add(edge);</span>
                        }
<span class="fc" id="L385">                        break;</span>
                    default:
<span class="fc bfc" id="L387" title="All 2 branches covered.">                        if (endSide == Side.PLUS) {</span>
<span class="fc" id="L388">                            plusList.add(edge);</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                        } else if (endSide == Side.MINUS) {</span>
<span class="fc" id="L390">                            minusList.add(edge);</span>
                        }
                        break;
                }
            }
        }

        // recurse through lower levels
<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (!plusList.isEmpty()) {</span>
<span class="fc" id="L399">            insertEdges(hyperplaneThickness, node.getPlus(),  plusList);</span>
<span class="fc" id="L400">        } else {</span>
<span class="fc" id="L401">            node.getPlus().setAttribute(Boolean.FALSE);</span>
        }
<span class="fc bfc" id="L403" title="All 2 branches covered.">        if (!minusList.isEmpty()) {</span>
<span class="fc" id="L404">            insertEdges(hyperplaneThickness, node.getMinus(), minusList);</span>
<span class="fc" id="L405">        } else {</span>
<span class="fc" id="L406">            node.getMinus().setAttribute(Boolean.TRUE);</span>
        }

<span class="fc" id="L409">    }</span>

    /** Internal class for holding vertices while they are processed to build a BSP tree. */
    private static class Vertex {

        /** Vertex location. */
        private final Vector2D location;

        /** Incoming edge. */
        private Edge incoming;

        /** Outgoing edge. */
        private Edge outgoing;

        /** Lines bound with this vertex. */
        private final List&lt;Line&gt; lines;

        /** Build a non-processed vertex not owned by any node yet.
         * @param location vertex location
         */
<span class="fc" id="L429">        public Vertex(final Vector2D location) {</span>
<span class="fc" id="L430">            this.location = location;</span>
<span class="fc" id="L431">            this.incoming = null;</span>
<span class="fc" id="L432">            this.outgoing = null;</span>
<span class="fc" id="L433">            this.lines    = new ArrayList&lt;Line&gt;();</span>
<span class="fc" id="L434">        }</span>

        /** Get Vertex location.
         * @return vertex location
         */
        public Vector2D getLocation() {
<span class="fc" id="L440">            return location;</span>
        }

        /** Bind a line considered to contain this vertex.
         * @param line line to bind with this vertex
         */
        public void bindWith(final Line line) {
<span class="fc" id="L447">            lines.add(line);</span>
<span class="fc" id="L448">        }</span>

        /** Get the common line bound with both the instance and another vertex, if any.
         * &lt;p&gt;
         * When two vertices are both bound to the same line, this means they are
         * already handled by node associated with this line, so there is no need
         * to create a cut hyperplane for them.
         * &lt;/p&gt;
         * @param vertex other vertex to check instance against
         * @return line bound with both the instance and another vertex, or null if the
         * two vertices do not share a line yet
         */
        public Line sharedLineWith(final Vertex vertex) {
<span class="fc bfc" id="L461" title="All 2 branches covered.">            for (final Line line1 : lines) {</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">                for (final Line line2 : vertex.lines) {</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">                    if (line1 == line2) {</span>
<span class="fc" id="L464">                        return line1;</span>
                    }
                }
            }
<span class="fc" id="L468">            return null;</span>
        }

        /** Set incoming edge.
         * &lt;p&gt;
         * The line supporting the incoming edge is automatically bound
         * with the instance.
         * &lt;/p&gt;
         * @param incoming incoming edge
         */
        public void setIncoming(final Edge incoming) {
<span class="fc" id="L479">            this.incoming = incoming;</span>
<span class="fc" id="L480">            bindWith(incoming.getLine());</span>
<span class="fc" id="L481">        }</span>

        /** Get incoming edge.
         * @return incoming edge
         */
        public Edge getIncoming() {
<span class="fc" id="L487">            return incoming;</span>
        }

        /** Set outgoing edge.
         * &lt;p&gt;
         * The line supporting the outgoing edge is automatically bound
         * with the instance.
         * &lt;/p&gt;
         * @param outgoing outgoing edge
         */
        public void setOutgoing(final Edge outgoing) {
<span class="fc" id="L498">            this.outgoing = outgoing;</span>
<span class="fc" id="L499">            bindWith(outgoing.getLine());</span>
<span class="fc" id="L500">        }</span>

        /** Get outgoing edge.
         * @return outgoing edge
         */
        public Edge getOutgoing() {
<span class="fc" id="L506">            return outgoing;</span>
        }

    }

    /** Internal class for holding edges while they are processed to build a BSP tree. */
    private static class Edge {

        /** Start vertex. */
        private final Vertex start;

        /** End vertex. */
        private final Vertex end;

        /** Line supporting the edge. */
        private final Line line;

        /** Node whose cut hyperplane contains this edge. */
        private BSPTree&lt;Euclidean2D&gt; node;

        /** Build an edge not contained in any node yet.
         * @param start start vertex
         * @param end end vertex
         * @param line line supporting the edge
         */
<span class="fc" id="L531">        public Edge(final Vertex start, final Vertex end, final Line line) {</span>

<span class="fc" id="L533">            this.start = start;</span>
<span class="fc" id="L534">            this.end   = end;</span>
<span class="fc" id="L535">            this.line  = line;</span>
<span class="fc" id="L536">            this.node  = null;</span>

            // connect the vertices back to the edge
<span class="fc" id="L539">            start.setOutgoing(this);</span>
<span class="fc" id="L540">            end.setIncoming(this);</span>

<span class="fc" id="L542">        }</span>

        /** Get start vertex.
         * @return start vertex
         */
        public Vertex getStart() {
<span class="fc" id="L548">            return start;</span>
        }

        /** Get end vertex.
         * @return end vertex
         */
        public Vertex getEnd() {
<span class="fc" id="L555">            return end;</span>
        }

        /** Get the line supporting this edge.
         * @return line supporting this edge
         */
        public Line getLine() {
<span class="fc" id="L562">            return line;</span>
        }

        /** Set the node whose cut hyperplane contains this edge.
         * @param node node whose cut hyperplane contains this edge
         */
        public void setNode(final BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L569">            this.node = node;</span>
<span class="fc" id="L570">        }</span>

        /** Get the node whose cut hyperplane contains this edge.
         * @return node whose cut hyperplane contains this edge
         * (null if edge has not yet been inserted into the BSP tree)
         */
        public BSPTree&lt;Euclidean2D&gt; getNode() {
<span class="fc" id="L577">            return node;</span>
        }

        /** Split the edge.
         * &lt;p&gt;
         * Once split, this edge is not referenced anymore by the vertices,
         * it is replaced by the two half-edges and an intermediate splitting
         * vertex is introduced to connect these two halves.
         * &lt;/p&gt;
         * @param splitLine line splitting the edge in two halves
         * @return split vertex (its incoming and outgoing edges are the two halves)
         */
        public Vertex split(final Line splitLine) {
<span class="fc" id="L590">            final Vertex splitVertex = new Vertex(line.intersection(splitLine));</span>
<span class="fc" id="L591">            splitVertex.bindWith(splitLine);</span>
<span class="fc" id="L592">            final Edge startHalf = new Edge(start, splitVertex, line);</span>
<span class="fc" id="L593">            final Edge endHalf   = new Edge(splitVertex, end, line);</span>
<span class="fc" id="L594">            startHalf.node = node;</span>
<span class="fc" id="L595">            endHalf.node   = node;</span>
<span class="fc" id="L596">            return splitVertex;</span>
        }

    }

    /** {@inheritDoc} */
    @Override
    public PolygonsSet buildNew(final BSPTree&lt;Euclidean2D&gt; tree) {
<span class="fc" id="L604">        return new PolygonsSet(tree, getTolerance());</span>
    }

    /** {@inheritDoc} */
    @Override
    protected void computeGeometricalProperties() {

<span class="fc" id="L611">        final Vector2D[][] v = getVertices();</span>

<span class="fc bfc" id="L613" title="All 2 branches covered.">        if (v.length == 0) {</span>
<span class="fc" id="L614">            final BSPTree&lt;Euclidean2D&gt; tree = getTree(false);</span>
<span class="fc bfc" id="L615" title="All 4 branches covered.">            if (tree.getCut() == null &amp;&amp; (Boolean) tree.getAttribute()) {</span>
                // the instance covers the whole space
<span class="fc" id="L617">                setSize(Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L618">                setBarycenter((Point&lt;Euclidean2D&gt;) Vector2D.NaN);</span>
<span class="fc" id="L619">            } else {</span>
<span class="fc" id="L620">                setSize(0);</span>
<span class="fc" id="L621">                setBarycenter((Point&lt;Euclidean2D&gt;) new Vector2D(0, 0));</span>
            }
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">        } else if (v[0][0] == null) {</span>
            // there is at least one open-loop: the polygon is infinite
<span class="nc" id="L625">            setSize(Double.POSITIVE_INFINITY);</span>
<span class="nc" id="L626">            setBarycenter((Point&lt;Euclidean2D&gt;) Vector2D.NaN);</span>
<span class="nc" id="L627">        } else {</span>
            // all loops are closed, we compute some integrals around the shape

<span class="fc" id="L630">            double sum  = 0;</span>
<span class="fc" id="L631">            double sumX = 0;</span>
<span class="fc" id="L632">            double sumY = 0;</span>

<span class="fc bfc" id="L634" title="All 2 branches covered.">            for (Vector2D[] loop : v) {</span>
<span class="fc" id="L635">                double x1 = loop[loop.length - 1].getX();</span>
<span class="fc" id="L636">                double y1 = loop[loop.length - 1].getY();</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">                for (final Vector2D point : loop) {</span>
<span class="fc" id="L638">                    final double x0 = x1;</span>
<span class="fc" id="L639">                    final double y0 = y1;</span>
<span class="fc" id="L640">                    x1 = point.getX();</span>
<span class="fc" id="L641">                    y1 = point.getY();</span>
<span class="fc" id="L642">                    final double factor = x0 * y1 - y0 * x1;</span>
<span class="fc" id="L643">                    sum  += factor;</span>
<span class="fc" id="L644">                    sumX += factor * (x0 + x1);</span>
<span class="fc" id="L645">                    sumY += factor * (y0 + y1);</span>
                }
            }

<span class="fc bfc" id="L649" title="All 2 branches covered.">            if (sum &lt; 0) {</span>
                // the polygon as a finite outside surrounded by an infinite inside
<span class="fc" id="L651">                setSize(Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L652">                setBarycenter((Point&lt;Euclidean2D&gt;) Vector2D.NaN);</span>
<span class="fc" id="L653">            } else {</span>
<span class="fc" id="L654">                setSize(sum / 2);</span>
<span class="fc" id="L655">                setBarycenter((Point&lt;Euclidean2D&gt;) new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));</span>
            }

        }

<span class="fc" id="L660">    }</span>

    /** Get the vertices of the polygon.
     * &lt;p&gt;The polygon boundary can be represented as an array of loops,
     * each loop being itself an array of vertices.&lt;/p&gt;
     * &lt;p&gt;In order to identify open loops which start and end by
     * infinite edges, the open loops arrays start with a null point. In
     * this case, the first non null point and the last point of the
     * array do not represent real vertices, they are dummy points
     * intended only to get the direction of the first and last edge. An
     * open loop consisting of a single infinite line will therefore be
     * represented by a three elements array with one null point
     * followed by two dummy points. The open loops are always the first
     * ones in the loops array.&lt;/p&gt;
     * &lt;p&gt;If the polygon has no boundary at all, a zero length loop
     * array will be returned.&lt;/p&gt;
     * &lt;p&gt;All line segments in the various loops have the inside of the
     * region on their left side and the outside on their right side
     * when moving in the underlying line direction. This means that
     * closed loops surrounding finite areas obey the direct
     * trigonometric orientation.&lt;/p&gt;
     * @return vertices of the polygon, organized as oriented boundary
     * loops with the open loops first (the returned value is guaranteed
     * to be non-null)
     */
    public Vector2D[][] getVertices() {
<span class="fc bfc" id="L686" title="All 2 branches covered.">        if (vertices == null) {</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">            if (getTree(false).getCut() == null) {</span>
<span class="fc" id="L688">                vertices = new Vector2D[0][];</span>
<span class="fc" id="L689">            } else {</span>

                // build the unconnected segments
<span class="fc" id="L692">                final SegmentsBuilder visitor = new SegmentsBuilder(getTolerance());</span>
<span class="fc" id="L693">                getTree(true).visit(visitor);</span>
<span class="fc" id="L694">                final List&lt;ConnectableSegment&gt; segments = visitor.getSegments();</span>

                // connect all segments, using topological criteria first
                // and using Euclidean distance only as a last resort
<span class="fc" id="L698">                int pending = segments.size();</span>
<span class="fc" id="L699">                pending -= naturalFollowerConnections(segments);</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">                if (pending &gt; 0) {</span>
<span class="fc" id="L701">                    pending -= splitEdgeConnections(segments);</span>
                }
<span class="fc bfc" id="L703" title="All 2 branches covered.">                if (pending &gt; 0) {</span>
<span class="fc" id="L704">                    pending -= closeVerticesConnections(segments);</span>
                }

                // create the segment loops
<span class="fc" id="L708">                final ArrayList&lt;List&lt;Segment&gt;&gt; loops = new ArrayList&lt;List&lt;Segment&gt;&gt;();</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">                for (ConnectableSegment s = getUnprocessed(segments); s != null; s = getUnprocessed(segments)) {</span>
<span class="fc" id="L710">                    final List&lt;Segment&gt; loop = followLoop(s);</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">                    if (loop != null) {</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">                        if (loop.get(0).getStart() == null) {</span>
                            // this is an open loop, we put it on the front
<span class="nc" id="L714">                            loops.add(0, loop);</span>
<span class="nc" id="L715">                        } else {</span>
                            // this is a closed loop, we put it on the back
<span class="fc" id="L717">                            loops.add(loop);</span>
                        }
                    }
                }

                // transform the loops in an array of arrays of points
<span class="fc" id="L723">                vertices = new Vector2D[loops.size()][];</span>
<span class="fc" id="L724">                int i = 0;</span>

<span class="fc bfc" id="L726" title="All 2 branches covered.">                for (final List&lt;Segment&gt; loop : loops) {</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">                    if (loop.size() &lt; 2 ||</span>
<span class="pc bpc" id="L728" title="5 of 6 branches missed.">                        (loop.size() == 2 &amp;&amp; loop.get(0).getStart() == null &amp;&amp; loop.get(1).getEnd() == null)) {</span>
                        // single infinite line
<span class="nc" id="L730">                        final Line line = loop.get(0).getLine();</span>
<span class="nc" id="L731">                        vertices[i++] = new Vector2D[] {</span>
                            null,
<span class="nc" id="L733">                            line.toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(-Float.MAX_VALUE)),</span>
<span class="nc" id="L734">                            line.toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(+Float.MAX_VALUE))</span>
                        };
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">                    } else if (loop.get(0).getStart() == null) {</span>
                        // open loop with at least one real point
<span class="nc" id="L738">                        final Vector2D[] array = new Vector2D[loop.size() + 2];</span>
<span class="nc" id="L739">                        int j = 0;</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                        for (Segment segment : loop) {</span>

<span class="nc bnc" id="L742" title="All 2 branches missed.">                            if (j == 0) {</span>
                                // null point and first dummy point
<span class="nc" id="L744">                                double x = segment.getLine().toSubSpace((Point&lt;Euclidean2D&gt;) segment.getEnd()).getX();</span>
<span class="nc" id="L745">                                x -= FastMath.max(1.0, FastMath.abs(x / 2));</span>
<span class="nc" id="L746">                                array[j++] = null;</span>
<span class="nc" id="L747">                                array[j++] = segment.getLine().toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(x));</span>
                            }

<span class="nc bnc" id="L750" title="All 2 branches missed.">                            if (j &lt; (array.length - 1)) {</span>
                                // current point
<span class="nc" id="L752">                                array[j++] = segment.getEnd();</span>
                            }

<span class="nc bnc" id="L755" title="All 2 branches missed.">                            if (j == (array.length - 1)) {</span>
                                // last dummy point
<span class="nc" id="L757">                                double x = segment.getLine().toSubSpace((Point&lt;Euclidean2D&gt;) segment.getStart()).getX();</span>
<span class="nc" id="L758">                                x += FastMath.max(1.0, FastMath.abs(x / 2));</span>
<span class="nc" id="L759">                                array[j++] = segment.getLine().toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(x));</span>
                            }

                        }
<span class="nc" id="L763">                        vertices[i++] = array;</span>
<span class="nc" id="L764">                    } else {</span>
<span class="fc" id="L765">                        final Vector2D[] array = new Vector2D[loop.size()];</span>
<span class="fc" id="L766">                        int j = 0;</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">                        for (Segment segment : loop) {</span>
<span class="fc" id="L768">                            array[j++] = segment.getStart();</span>
                        }
<span class="fc" id="L770">                        vertices[i++] = array;</span>
                    }
                }

            }
        }

<span class="fc" id="L777">        return vertices.clone();</span>

    }

    /** Connect the segments using only natural follower information.
     * @param segments segments complete segments list
     * @return number of connections performed
     */
    private int naturalFollowerConnections(final List&lt;ConnectableSegment&gt; segments) {
<span class="fc" id="L786">        int connected = 0;</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">        for (final ConnectableSegment segment : segments) {</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">            if (segment.getNext() == null) {</span>
<span class="fc" id="L789">                final BSPTree&lt;Euclidean2D&gt; node = segment.getNode();</span>
<span class="fc" id="L790">                final BSPTree&lt;Euclidean2D&gt; end  = segment.getEndNode();</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">                for (final ConnectableSegment candidateNext : segments) {</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">                    if (candidateNext.getPrevious()  == null &amp;&amp;</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">                        candidateNext.getNode()      == end &amp;&amp;</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">                        candidateNext.getStartNode() == node) {</span>
                        // connect the two segments
<span class="fc" id="L796">                        segment.setNext(candidateNext);</span>
<span class="fc" id="L797">                        candidateNext.setPrevious(segment);</span>
<span class="fc" id="L798">                        ++connected;</span>
<span class="fc" id="L799">                        break;</span>
                    }
                }
            }
        }
<span class="fc" id="L804">        return connected;</span>
    }

    /** Connect the segments resulting from a line splitting a straight edge.
     * @param segments segments complete segments list
     * @return number of connections performed
     */
    private int splitEdgeConnections(final List&lt;ConnectableSegment&gt; segments) {
<span class="fc" id="L812">        int connected = 0;</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">        for (final ConnectableSegment segment : segments) {</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">            if (segment.getNext() == null) {</span>
<span class="fc" id="L815">                final Hyperplane&lt;Euclidean2D&gt; hyperplane = segment.getNode().getCut().getHyperplane();</span>
<span class="fc" id="L816">                final BSPTree&lt;Euclidean2D&gt; end  = segment.getEndNode();</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">                for (final ConnectableSegment candidateNext : segments) {</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">                    if (candidateNext.getPrevious()                      == null &amp;&amp;</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">                        candidateNext.getNode().getCut().getHyperplane() == hyperplane &amp;&amp;</span>
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">                        candidateNext.getStartNode()                     == end) {</span>
                        // connect the two segments
<span class="nc" id="L822">                        segment.setNext(candidateNext);</span>
<span class="nc" id="L823">                        candidateNext.setPrevious(segment);</span>
<span class="nc" id="L824">                        ++connected;</span>
<span class="nc" id="L825">                        break;</span>
                    }
                }
            }
        }
<span class="fc" id="L830">        return connected;</span>
    }

    /** Connect the segments using Euclidean distance.
     * &lt;p&gt;
     * This connection heuristic should be used last, as it relies
     * only on a fuzzy distance criterion.
     * &lt;/p&gt;
     * @param segments segments complete segments list
     * @return number of connections performed
     */
    private int closeVerticesConnections(final List&lt;ConnectableSegment&gt; segments) {
<span class="fc" id="L842">        int connected = 0;</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">        for (final ConnectableSegment segment : segments) {</span>
<span class="pc bpc" id="L844" title="1 of 4 branches missed.">            if (segment.getNext() == null &amp;&amp; segment.getEnd() != null) {</span>
<span class="fc" id="L845">                final Vector2D end = segment.getEnd();</span>
<span class="fc" id="L846">                ConnectableSegment selectedNext = null;</span>
<span class="fc" id="L847">                double min = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">                for (final ConnectableSegment candidateNext : segments) {</span>
<span class="pc bpc" id="L849" title="1 of 4 branches missed.">                    if (candidateNext.getPrevious() == null &amp;&amp; candidateNext.getStart() != null) {</span>
<span class="fc" id="L850">                        final double distance = Vector2D.distance(end, candidateNext.getStart());</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">                        if (distance &lt; min) {</span>
<span class="fc" id="L852">                            selectedNext = candidateNext;</span>
<span class="fc" id="L853">                            min          = distance;</span>
                        }
                    }
                }
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">                if (min &lt;= getTolerance()) {</span>
                    // connect the two segments
<span class="fc" id="L859">                    segment.setNext(selectedNext);</span>
<span class="fc" id="L860">                    selectedNext.setPrevious(segment);</span>
<span class="fc" id="L861">                    ++connected;</span>
                }
            }
        }
<span class="fc" id="L865">        return connected;</span>
    }

    /** Get first unprocessed segment from a list.
     * @param segments segments list
     * @return first segment that has not been processed yet
     * or null if all segments have been processed
     */
    private ConnectableSegment getUnprocessed(final List&lt;ConnectableSegment&gt; segments) {
<span class="fc bfc" id="L874" title="All 2 branches covered.">        for (final ConnectableSegment segment : segments) {</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">            if (!segment.isProcessed()) {</span>
<span class="fc" id="L876">                return segment;</span>
            }
        }
<span class="fc" id="L879">        return null;</span>
    }

    /** Build the loop containing a segment.
     * &lt;p&gt;
     * The segment put in the loop will be marked as processed.
     * &lt;/p&gt;
     * @param defining segment used to define the loop
     * @return loop containing the segment (may be null if the loop is a
     * degenerated infinitely thin 2 points loop
     */
    private List&lt;Segment&gt; followLoop(final ConnectableSegment defining) {

<span class="fc" id="L892">        final List&lt;Segment&gt; loop = new ArrayList&lt;Segment&gt;();</span>
<span class="fc" id="L893">        loop.add(defining);</span>
<span class="fc" id="L894">        defining.setProcessed(true);</span>

        // add segments in connection order
<span class="fc" id="L897">        ConnectableSegment next = defining.getNext();</span>
<span class="pc bpc" id="L898" title="1 of 4 branches missed.">        while (next != defining &amp;&amp; next != null) {</span>
<span class="fc" id="L899">            loop.add(next);</span>
<span class="fc" id="L900">            next.setProcessed(true);</span>
<span class="fc" id="L901">            next = next.getNext();</span>
        }

<span class="pc bpc" id="L904" title="1 of 2 branches missed.">        if (next == null) {</span>
            // the loop is open and we have found its end,
            // we need to find its start too
<span class="nc" id="L907">            ConnectableSegment previous = defining.getPrevious();</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            while (previous != null) {</span>
<span class="nc" id="L909">                loop.add(0, previous);</span>
<span class="nc" id="L910">                previous.setProcessed(true);</span>
<span class="nc" id="L911">                previous = previous.getPrevious();</span>
            }
        }

        // filter out spurious vertices
<span class="fc" id="L916">        filterSpuriousVertices(loop);</span>

<span class="pc bpc" id="L918" title="1 of 4 branches missed.">        if (loop.size() == 2 &amp;&amp; loop.get(0).getStart() != null) {</span>
            // this is a degenerated infinitely thin closed loop, we simply ignore it
<span class="fc" id="L920">            return null;</span>
        } else {
<span class="fc" id="L922">            return loop;</span>
        }

    }

    /** Filter out spurious vertices on straight lines (at machine precision).
     * @param loop segments loop to filter (will be modified in-place)
     */
    private void filterSpuriousVertices(final List&lt;Segment&gt; loop) {
<span class="fc bfc" id="L931" title="All 2 branches covered.">        for (int i = 0; i &lt; loop.size(); ++i) {</span>
<span class="fc" id="L932">            final Segment previous = loop.get(i);</span>
<span class="fc" id="L933">            int j = (i + 1) % loop.size();</span>
<span class="fc" id="L934">            final Segment next = loop.get(j);</span>
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">            if (next != null &amp;&amp;</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">                Precision.equals(previous.getLine().getAngle(), next.getLine().getAngle(), Precision.EPSILON)) {</span>
                // the vertex between the two edges is a spurious one
                // replace the two segments by a single one
<span class="fc" id="L939">                loop.set(j, new Segment(previous.getStart(), next.getEnd(), previous.getLine()));</span>
<span class="fc" id="L940">                loop.remove(i--);</span>
            }
        }
<span class="fc" id="L943">    }</span>

    /** Private extension of Segment allowing connection. */
    private static class ConnectableSegment extends Segment {

        /** Node containing segment. */
        private final BSPTree&lt;Euclidean2D&gt; node;

        /** Node whose intersection with current node defines start point. */
        private final BSPTree&lt;Euclidean2D&gt; startNode;

        /** Node whose intersection with current node defines end point. */
        private final BSPTree&lt;Euclidean2D&gt; endNode;

        /** Previous segment. */
        private ConnectableSegment previous;

        /** Next segment. */
        private ConnectableSegment next;

        /** Indicator for completely processed segments. */
        private boolean processed;

        /** Build a segment.
         * @param start start point of the segment
         * @param end end point of the segment
         * @param line line containing the segment
         * @param node node containing the segment
         * @param startNode node whose intersection with current node defines start point
         * @param endNode node whose intersection with current node defines end point
         */
        public ConnectableSegment(final Vector2D start, final Vector2D end, final Line line,
                                  final BSPTree&lt;Euclidean2D&gt; node,
                                  final BSPTree&lt;Euclidean2D&gt; startNode,
                                  final BSPTree&lt;Euclidean2D&gt; endNode) {
<span class="fc" id="L978">            super(start, end, line);</span>
<span class="fc" id="L979">            this.node      = node;</span>
<span class="fc" id="L980">            this.startNode = startNode;</span>
<span class="fc" id="L981">            this.endNode   = endNode;</span>
<span class="fc" id="L982">            this.previous  = null;</span>
<span class="fc" id="L983">            this.next      = null;</span>
<span class="fc" id="L984">            this.processed = false;</span>
<span class="fc" id="L985">        }</span>

        /** Get the node containing segment.
         * @return node containing segment
         */
        public BSPTree&lt;Euclidean2D&gt; getNode() {
<span class="fc" id="L991">            return node;</span>
        }

        /** Get the node whose intersection with current node defines start point.
         * @return node whose intersection with current node defines start point
         */
        public BSPTree&lt;Euclidean2D&gt; getStartNode() {
<span class="fc" id="L998">            return startNode;</span>
        }

        /** Get the node whose intersection with current node defines end point.
         * @return node whose intersection with current node defines end point
         */
        public BSPTree&lt;Euclidean2D&gt; getEndNode() {
<span class="fc" id="L1005">            return endNode;</span>
        }

        /** Get the previous segment.
         * @return previous segment
         */
        public ConnectableSegment getPrevious() {
<span class="fc" id="L1012">            return previous;</span>
        }

        /** Set the previous segment.
         * @param previous previous segment
         */
        public void setPrevious(final ConnectableSegment previous) {
<span class="fc" id="L1019">            this.previous = previous;</span>
<span class="fc" id="L1020">        }</span>

        /** Get the next segment.
         * @return next segment
         */
        public ConnectableSegment getNext() {
<span class="fc" id="L1026">            return next;</span>
        }

        /** Set the next segment.
         * @param next previous segment
         */
        public void setNext(final ConnectableSegment next) {
<span class="fc" id="L1033">            this.next = next;</span>
<span class="fc" id="L1034">        }</span>

        /** Set the processed flag.
         * @param processed processed flag to set
         */
        public void setProcessed(final boolean processed) {
<span class="fc" id="L1040">            this.processed = processed;</span>
<span class="fc" id="L1041">        }</span>

        /** Check if the segment has been processed.
         * @return true if the segment has been processed
         */
        public boolean isProcessed() {
<span class="fc" id="L1047">            return processed;</span>
        }

    }

    /** Visitor building segments. */
    private static class SegmentsBuilder implements BSPTreeVisitor&lt;Euclidean2D&gt; {

        /** Tolerance for close nodes connection. */
        private final double tolerance;

        /** Built segments. */
        private final List&lt;ConnectableSegment&gt; segments;

        /** Simple constructor.
         * @param tolerance tolerance for close nodes connection
         */
<span class="fc" id="L1064">        public SegmentsBuilder(final double tolerance) {</span>
<span class="fc" id="L1065">            this.tolerance = tolerance;</span>
<span class="fc" id="L1066">            this.segments  = new ArrayList&lt;ConnectableSegment&gt;();</span>
<span class="fc" id="L1067">        }</span>

        /** {@inheritDoc} */
        public Order visitOrder(final BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L1071">            return Order.MINUS_SUB_PLUS;</span>
        }

        /** {@inheritDoc} */
        public void visitInternalNode(final BSPTree&lt;Euclidean2D&gt; node) {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1077">            final BoundaryAttribute&lt;Euclidean2D&gt; attribute = (BoundaryAttribute&lt;Euclidean2D&gt;) node.getAttribute();</span>
<span class="fc" id="L1078">            final Iterable&lt;BSPTree&lt;Euclidean2D&gt;&gt; splitters = attribute.getSplitters();</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">            if (attribute.getPlusOutside() != null) {</span>
<span class="fc" id="L1080">                addContribution(attribute.getPlusOutside(), node, splitters, false);</span>
            }
<span class="fc bfc" id="L1082" title="All 2 branches covered.">            if (attribute.getPlusInside() != null) {</span>
<span class="fc" id="L1083">                addContribution(attribute.getPlusInside(), node, splitters, true);</span>
            }
<span class="fc" id="L1085">        }</span>

        /** {@inheritDoc} */
        public void visitLeafNode(final BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L1089">        }</span>

        /** Add the contribution of a boundary facet.
         * @param sub boundary facet
         * @param node node containing segment
         * @param splitters splitters for the boundary facet
         * @param reversed if true, the facet has the inside on its plus side
         */
        private void addContribution(final SubHyperplane&lt;Euclidean2D&gt; sub,
                                     final BSPTree&lt;Euclidean2D&gt; node,
                                     final Iterable&lt;BSPTree&lt;Euclidean2D&gt;&gt; splitters,
                                     final boolean reversed) {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1102">            final AbstractSubHyperplane&lt;Euclidean2D, Euclidean1D&gt; absSub =</span>
<span class="fc" id="L1103">                (AbstractSubHyperplane&lt;Euclidean2D, Euclidean1D&gt;) sub;</span>
<span class="fc" id="L1104">            final Line line      = (Line) sub.getHyperplane();</span>
<span class="fc" id="L1105">            final List&lt;Interval&gt; intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();</span>
<span class="fc bfc" id="L1106" title="All 2 branches covered.">            for (final Interval i : intervals) {</span>

                // find the 2D points
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">                final Vector2D startV = Double.isInfinite(i.getInf()) ?</span>
<span class="pc" id="L1110">                                        null : (Vector2D) line.toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(i.getInf()));</span>
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">                final Vector2D endV   = Double.isInfinite(i.getSup()) ?</span>
<span class="pc" id="L1112">                                        null : (Vector2D) line.toSpace((Point&lt;Euclidean1D&gt;) new Vector1D(i.getSup()));</span>

                // recover the connectivity information
<span class="fc" id="L1115">                final BSPTree&lt;Euclidean2D&gt; startN = selectClosest(startV, splitters);</span>
<span class="fc" id="L1116">                final BSPTree&lt;Euclidean2D&gt; endN   = selectClosest(endV, splitters);</span>

<span class="fc bfc" id="L1118" title="All 2 branches covered.">                if (reversed) {</span>
<span class="fc" id="L1119">                    segments.add(new ConnectableSegment(endV, startV, line.getReverse(),</span>
<span class="fc" id="L1120">                                                        node, endN, startN));</span>
<span class="fc" id="L1121">                } else {</span>
<span class="fc" id="L1122">                    segments.add(new ConnectableSegment(startV, endV, line,</span>
<span class="fc" id="L1123">                                                        node, startN, endN));</span>
                }

            }
<span class="fc" id="L1127">        }</span>

        /** Select the node whose cut sub-hyperplane is closest to specified point.
         * @param point reference point
         * @param candidates candidate nodes
         * @return node closest to point, or null if no node is closer than tolerance
         */
        private BSPTree&lt;Euclidean2D&gt; selectClosest(final Vector2D point, final Iterable&lt;BSPTree&lt;Euclidean2D&gt;&gt; candidates) {

<span class="fc" id="L1136">            BSPTree&lt;Euclidean2D&gt; selected = null;</span>
<span class="fc" id="L1137">            double min = Double.POSITIVE_INFINITY;</span>

<span class="fc bfc" id="L1139" title="All 2 branches covered.">            for (final BSPTree&lt;Euclidean2D&gt; node : candidates) {</span>
<span class="fc" id="L1140">                final double distance = FastMath.abs(node.getCut().getHyperplane().getOffset(point));</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">                if (distance &lt; min) {</span>
<span class="fc" id="L1142">                    selected = node;</span>
<span class="fc" id="L1143">                    min      = distance;</span>
                }
            }

<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">            return min &lt;= tolerance ? selected : null;</span>

        }

        /** Get the segments.
         * @return built segments
         */
        public List&lt;ConnectableSegment&gt; getSegments() {
<span class="fc" id="L1155">            return segments;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>