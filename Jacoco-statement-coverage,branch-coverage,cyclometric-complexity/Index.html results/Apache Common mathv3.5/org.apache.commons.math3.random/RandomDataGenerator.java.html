<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RandomDataGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.random</a> &gt; <span class="el_source">RandomDataGenerator.java</span></div><h1>RandomDataGenerator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math3.random;

import java.io.Serializable;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import java.util.Collection;

import org.apache.commons.math3.distribution.BetaDistribution;
import org.apache.commons.math3.distribution.BinomialDistribution;
import org.apache.commons.math3.distribution.CauchyDistribution;
import org.apache.commons.math3.distribution.ChiSquaredDistribution;
import org.apache.commons.math3.distribution.ExponentialDistribution;
import org.apache.commons.math3.distribution.FDistribution;
import org.apache.commons.math3.distribution.GammaDistribution;
import org.apache.commons.math3.distribution.HypergeometricDistribution;
import org.apache.commons.math3.distribution.PascalDistribution;
import org.apache.commons.math3.distribution.PoissonDistribution;
import org.apache.commons.math3.distribution.TDistribution;
import org.apache.commons.math3.distribution.WeibullDistribution;
import org.apache.commons.math3.distribution.ZipfDistribution;
import org.apache.commons.math3.distribution.UniformIntegerDistribution;
import org.apache.commons.math3.exception.MathInternalError;
import org.apache.commons.math3.exception.NotANumberException;
import org.apache.commons.math3.exception.NotFiniteNumberException;
import org.apache.commons.math3.exception.NotPositiveException;
import org.apache.commons.math3.exception.NotStrictlyPositiveException;
import org.apache.commons.math3.exception.NumberIsTooLargeException;
import org.apache.commons.math3.exception.OutOfRangeException;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.util.MathArrays;

/**
 * Implements the {@link RandomData} interface using a {@link RandomGenerator}
 * instance to generate non-secure data and a {@link java.security.SecureRandom}
 * instance to provide data for the &lt;code&gt;nextSecureXxx&lt;/code&gt; methods. If no
 * &lt;code&gt;RandomGenerator&lt;/code&gt; is provided in the constructor, the default is
 * to use a {@link Well19937c} generator. To plug in a different
 * implementation, either implement &lt;code&gt;RandomGenerator&lt;/code&gt; directly or
 * extend {@link AbstractRandomGenerator}.
 * &lt;p&gt;
 * Supports reseeding the underlying pseudo-random number generator (PRNG). The
 * &lt;code&gt;SecurityProvider&lt;/code&gt; and &lt;code&gt;Algorithm&lt;/code&gt; used by the
 * &lt;code&gt;SecureRandom&lt;/code&gt; instance can also be reset.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For details on the default PRNGs, see {@link java.util.Random} and
 * {@link java.security.SecureRandom}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Usage Notes&lt;/strong&gt;:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Instance variables are used to maintain &lt;code&gt;RandomGenerator&lt;/code&gt; and
 * &lt;code&gt;SecureRandom&lt;/code&gt; instances used in data generation. Therefore, to
 * generate a random sequence of values or strings, you should use just
 * &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;RandomDataImpl&lt;/code&gt; instance repeatedly.&lt;/li&gt;
 * &lt;li&gt;
 * The &quot;secure&quot; methods are *much* slower. These should be used only when a
 * cryptographically secure random sequence is required. A secure random
 * sequence is a sequence of pseudo-random values which, in addition to being
 * well-dispersed (so no subsequence of values is an any more likely than other
 * subsequence of the the same length), also has the additional property that
 * knowledge of values generated up to any point in the sequence does not make
 * it any easier to predict subsequent values.&lt;/li&gt;
 * &lt;li&gt;
 * When a new &lt;code&gt;RandomDataImpl&lt;/code&gt; is created, the underlying random
 * number generators are &lt;strong&gt;not&lt;/strong&gt; initialized. If you do not
 * explicitly seed the default non-secure generator, it is seeded with the
 * current time in milliseconds plus the system identity hash code on first use.
 * The same holds for the secure generator. If you provide a &lt;code&gt;RandomGenerator&lt;/code&gt;
 * to the constructor, however, this generator is not reseeded by the constructor
 * nor is it reseeded on first use.&lt;/li&gt;
 * &lt;li&gt;
 * The &lt;code&gt;reSeed&lt;/code&gt; and &lt;code&gt;reSeedSecure&lt;/code&gt; methods delegate to the
 * corresponding methods on the underlying &lt;code&gt;RandomGenerator&lt;/code&gt; and
 * &lt;code&gt;SecureRandom&lt;/code&gt; instances. Therefore, &lt;code&gt;reSeed(long)&lt;/code&gt;
 * fully resets the initial state of the non-secure random number generator (so
 * that reseeding with a specific value always results in the same subsequent
 * random sequence); whereas reSeedSecure(long) does &lt;strong&gt;not&lt;/strong&gt;
 * reinitialize the secure random number generator (so secure sequences started
 * with calls to reseedSecure(long) won't be identical).&lt;/li&gt;
 * &lt;li&gt;
 * This implementation is not synchronized. The underlying &lt;code&gt;RandomGenerator&lt;/code&gt;
 * or &lt;code&gt;SecureRandom&lt;/code&gt; instances are not protected by synchronization and
 * are not guaranteed to be thread-safe.  Therefore, if an instance of this class
 * is concurrently utilized by multiple threads, it is the responsibility of
 * client code to synchronize access to seeding and data generation methods.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * @since 3.1
 */
public class RandomDataGenerator implements RandomData, Serializable {

    /** Serializable version identifier */
    private static final long serialVersionUID = -626730818244969716L;

    /** underlying random number generator */
<span class="fc" id="L118">    private RandomGenerator rand = null;</span>

    /** underlying secure random number generator */
<span class="fc" id="L121">    private RandomGenerator secRand = null;</span>

    /**
     * Construct a RandomDataGenerator, using a default random generator as the source
     * of randomness.
     *
     * &lt;p&gt;The default generator is a {@link Well19937c} seeded
     * with {@code System.currentTimeMillis() + System.identityHashCode(this))}.
     * The generator is initialized and seeded on first use.&lt;/p&gt;
     */
<span class="fc" id="L131">    public RandomDataGenerator() {</span>
<span class="fc" id="L132">    }</span>

    /**
     * Construct a RandomDataGenerator using the supplied {@link RandomGenerator} as
     * the source of (non-secure) random data.
     *
     * @param rand the source of (non-secure) random data
     * (may be null, resulting in the default generator)
     */
<span class="fc" id="L141">    public RandomDataGenerator(RandomGenerator rand) {</span>
<span class="fc" id="L142">        this.rand = rand;</span>
<span class="fc" id="L143">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description:&lt;/strong&gt; hex strings are generated using a
     * 2-step process.
     * &lt;ol&gt;
     * &lt;li&gt;{@code len / 2 + 1} binary bytes are generated using the underlying
     * Random&lt;/li&gt;
     * &lt;li&gt;Each binary byte is translated into 2 hex digits&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;/p&gt;
     *
     * @param len the desired string length.
     * @return the random string.
     * @throws NotStrictlyPositiveException if {@code len &lt;= 0}.
     */
    public String nextHexString(int len) throws NotStrictlyPositiveException {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (len &lt;= 0) {</span>
<span class="fc" id="L163">            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);</span>
        }

        // Get a random number generator
<span class="fc" id="L167">        RandomGenerator ran = getRandomGenerator();</span>

        // Initialize output buffer
<span class="fc" id="L170">        StringBuilder outBuffer = new StringBuilder();</span>

        // Get int(len/2)+1 random bytes
<span class="fc" id="L173">        byte[] randomBytes = new byte[(len / 2) + 1];</span>
<span class="fc" id="L174">        ran.nextBytes(randomBytes);</span>

        // Convert each byte to 2 hex digits
<span class="fc bfc" id="L177" title="All 2 branches covered.">        for (int i = 0; i &lt; randomBytes.length; i++) {</span>
<span class="fc" id="L178">            Integer c = Integer.valueOf(randomBytes[i]);</span>

            /*
             * Add 128 to byte value to make interval 0-255 before doing hex
             * conversion. This guarantees &lt;= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
<span class="fc" id="L185">            String hex = Integer.toHexString(c.intValue() + 128);</span>

            // Make sure we add 2 hex digits for each byte
<span class="fc bfc" id="L188" title="All 2 branches covered.">            if (hex.length() == 1) {</span>
<span class="fc" id="L189">                hex = &quot;0&quot; + hex;</span>
            }
<span class="fc" id="L191">            outBuffer.append(hex);</span>
        }
<span class="fc" id="L193">        return outBuffer.toString().substring(0, len);</span>
    }

    /** {@inheritDoc} */
    public int nextInt(final int lower, final int upper) throws NumberIsTooLargeException {
<span class="fc" id="L198">        return new UniformIntegerDistribution(getRandomGenerator(), lower, upper).sample();</span>
    }

    /** {@inheritDoc} */
    public long nextLong(final long lower, final long upper) throws NumberIsTooLargeException {
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (lower &gt;= upper) {</span>
<span class="fc" id="L204">            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,</span>
<span class="fc" id="L205">                                                lower, upper, false);</span>
        }
<span class="fc" id="L207">        final long max = (upper - lower) + 1;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (max &lt;= 0) {</span>
            // the range is too wide to fit in a positive long (larger than 2^63); as it covers
            // more than half the long range, we use directly a simple rejection method
<span class="fc" id="L211">            final RandomGenerator rng = getRandomGenerator();</span>
            while (true) {
<span class="fc" id="L213">                final long r = rng.nextLong();</span>
<span class="fc bfc" id="L214" title="All 4 branches covered.">                if (r &gt;= lower &amp;&amp; r &lt;= upper) {</span>
<span class="fc" id="L215">                    return r;</span>
                }
            }
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        } else if (max &lt; Integer.MAX_VALUE){</span>
            // we can shift the range and generate directly a positive int
<span class="fc" id="L220">            return lower + getRandomGenerator().nextInt((int) max);</span>
        } else {
            // we can shift the range and generate directly a positive long
<span class="nc" id="L223">            return lower + nextLong(getRandomGenerator(), max);</span>
        }
    }

    /**
     * Returns a pseudorandom, uniformly distributed {@code long} value
     * between 0 (inclusive) and the specified value (exclusive), drawn from
     * this random number generator's sequence.
     *
     * @param rng random generator to use
     * @param n the bound on the random number to be returned.  Must be
     * positive.
     * @return  a pseudorandom, uniformly distributed {@code long}
     * value between 0 (inclusive) and n (exclusive).
     * @throws IllegalArgumentException  if n is not positive.
     */
    private static long nextLong(final RandomGenerator rng, final long n) throws IllegalArgumentException {
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (n &gt; 0) {</span>
<span class="nc" id="L241">            final byte[] byteArray = new byte[8];</span>
            long bits;
            long val;
<span class="nc bnc" id="L244" title="All 2 branches missed.">            do {</span>
<span class="nc" id="L245">                rng.nextBytes(byteArray);</span>
<span class="nc" id="L246">                bits = 0;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                for (final byte b : byteArray) {</span>
<span class="nc" id="L248">                    bits = (bits &lt;&lt; 8) | (((long) b) &amp; 0xffL);</span>
                }
<span class="nc" id="L250">                bits &amp;= 0x7fffffffffffffffL;</span>
<span class="nc" id="L251">                val  = bits % n;</span>
<span class="nc" id="L252">            } while (bits - val + (n - 1) &lt; 0);</span>
<span class="nc" id="L253">            return val;</span>
        }
<span class="nc" id="L255">        throw new NotStrictlyPositiveException(n);</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description:&lt;/strong&gt; hex strings are generated in
     * 40-byte segments using a 3-step process.
     * &lt;ol&gt;
     * &lt;li&gt;
     * 20 random bytes are generated using the underlying
     * &lt;code&gt;SecureRandom&lt;/code&gt;.&lt;/li&gt;
     * &lt;li&gt;
     * SHA-1 hash is applied to yield a 20-byte binary digest.&lt;/li&gt;
     * &lt;li&gt;
     * Each byte of the binary digest is converted to 2 hex digits.&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;/p&gt;
     * @throws NotStrictlyPositiveException if {@code len &lt;= 0}
     */
    public String nextSecureHexString(int len) throws NotStrictlyPositiveException {
<span class="fc bfc" id="L276" title="All 2 branches covered.">        if (len &lt;= 0) {</span>
<span class="fc" id="L277">            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);</span>
        }

        // Get SecureRandom and setup Digest provider
<span class="fc" id="L281">        final RandomGenerator secRan = getSecRan();</span>
<span class="fc" id="L282">        MessageDigest alg = null;</span>
        try {
<span class="fc" id="L284">            alg = MessageDigest.getInstance(&quot;SHA-1&quot;);</span>
<span class="pc" id="L285">        } catch (NoSuchAlgorithmException ex) {</span>
            // this should never happen
<span class="nc" id="L287">            throw new MathInternalError(ex);</span>
        }
<span class="fc" id="L289">        alg.reset();</span>

        // Compute number of iterations required (40 bytes each)
<span class="fc" id="L292">        int numIter = (len / 40) + 1;</span>

<span class="fc" id="L294">        StringBuilder outBuffer = new StringBuilder();</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (int iter = 1; iter &lt; numIter + 1; iter++) {</span>
<span class="fc" id="L296">            byte[] randomBytes = new byte[40];</span>
<span class="fc" id="L297">            secRan.nextBytes(randomBytes);</span>
<span class="fc" id="L298">            alg.update(randomBytes);</span>

            // Compute hash -- will create 20-byte binary hash
<span class="fc" id="L301">            byte[] hash = alg.digest();</span>

            // Loop over the hash, converting each byte to 2 hex digits
<span class="fc bfc" id="L304" title="All 2 branches covered.">            for (int i = 0; i &lt; hash.length; i++) {</span>
<span class="fc" id="L305">                Integer c = Integer.valueOf(hash[i]);</span>

                /*
                 * Add 128 to byte value to make interval 0-255 This guarantees
                 * &lt;= 2 hex digits from toHexString() toHexString would
                 * otherwise add 2^32 to negative arguments
                 */
<span class="fc" id="L312">                String hex = Integer.toHexString(c.intValue() + 128);</span>

                // Keep strings uniform length -- guarantees 40 bytes
<span class="fc bfc" id="L315" title="All 2 branches covered.">                if (hex.length() == 1) {</span>
<span class="fc" id="L316">                    hex = &quot;0&quot; + hex;</span>
                }
<span class="fc" id="L318">                outBuffer.append(hex);</span>
            }
        }
<span class="fc" id="L321">        return outBuffer.toString().substring(0, len);</span>
    }

    /**  {@inheritDoc} */
    public int nextSecureInt(final int lower, final int upper) throws NumberIsTooLargeException {
<span class="fc" id="L326">        return new UniformIntegerDistribution(getSecRan(), lower, upper).sample();</span>
    }

    /** {@inheritDoc} */
    public long nextSecureLong(final long lower, final long upper) throws NumberIsTooLargeException {
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (lower &gt;= upper) {</span>
<span class="fc" id="L332">            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,</span>
<span class="fc" id="L333">                                                lower, upper, false);</span>
        }
<span class="fc" id="L335">        final RandomGenerator rng = getSecRan();</span>
<span class="fc" id="L336">        final long max = (upper - lower) + 1;</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (max &lt;= 0) {</span>
            // the range is too wide to fit in a positive long (larger than 2^63); as it covers
            // more than half the long range, we use directly a simple rejection method
            while (true) {
<span class="nc" id="L341">                final long r = rng.nextLong();</span>
<span class="nc bnc" id="L342" title="All 4 branches missed.">                if (r &gt;= lower &amp;&amp; r &lt;= upper) {</span>
<span class="nc" id="L343">                    return r;</span>
                }
            }
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        } else if (max &lt; Integer.MAX_VALUE){</span>
            // we can shift the range and generate directly a positive int
<span class="fc" id="L348">            return lower + rng.nextInt((int) max);</span>
        } else {
            // we can shift the range and generate directly a positive long
<span class="nc" id="L351">            return lower + nextLong(rng, max);</span>
        }
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description&lt;/strong&gt;:
     * &lt;ul&gt;&lt;li&gt; For small means, uses simulation of a Poisson process
     * using Uniform deviates, as described
     * &lt;a href=&quot;http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm&quot;&gt; here.&lt;/a&gt;
     * The Poisson process (and hence value returned) is bounded by 1000 * mean.&lt;/li&gt;
     *
     * &lt;li&gt; For large means, uses the rejection algorithm described in &lt;br/&gt;
     * Devroye, Luc. (1981).&lt;i&gt;The Computer Generation of Poisson Random Variables&lt;/i&gt;
     * &lt;strong&gt;Computing&lt;/strong&gt; vol. 26 pp. 197-207.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
     * @throws NotStrictlyPositiveException if {@code len &lt;= 0}
     */
    public long nextPoisson(double mean) throws NotStrictlyPositiveException {
<span class="fc" id="L370">        return new PoissonDistribution(getRandomGenerator(), mean,</span>
<span class="fc" id="L371">                PoissonDistribution.DEFAULT_EPSILON,</span>
<span class="fc" id="L372">                PoissonDistribution.DEFAULT_MAX_ITERATIONS).sample();</span>
    }

    /** {@inheritDoc} */
    public double nextGaussian(double mu, double sigma) throws NotStrictlyPositiveException {
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (sigma &lt;= 0) {</span>
<span class="fc" id="L378">            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sigma);</span>
        }
<span class="fc" id="L380">        return sigma * getRandomGenerator().nextGaussian() + mu;</span>
    }

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: Uses the Algorithm SA (Ahrens)
     * from p. 876 in:
     * [1]: Ahrens, J. H. and Dieter, U. (1972). Computer methods for
     * sampling from the exponential and normal distributions.
     * Communications of the ACM, 15, 873-882.
     * &lt;/p&gt;
     */
    public double nextExponential(double mean) throws NotStrictlyPositiveException {
<span class="fc" id="L395">        return new ExponentialDistribution(getRandomGenerator(), mean,</span>
<span class="fc" id="L396">                ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();</span>
    }

    /**
     * &lt;p&gt;Generates a random value from the
     * {@link org.apache.commons.math3.distribution.GammaDistribution Gamma Distribution}.&lt;/p&gt;
     *
     * &lt;p&gt;This implementation uses the following algorithms: &lt;/p&gt;
     *
     * &lt;p&gt;For 0 &lt; shape &lt; 1: &lt;br/&gt;
     * Ahrens, J. H. and Dieter, U., &lt;i&gt;Computer methods for
     * sampling from gamma, beta, Poisson and binomial distributions.&lt;/i&gt;
     * Computing, 12, 223-246, 1974.&lt;/p&gt;
     *
     * &lt;p&gt;For shape &gt;= 1: &lt;br/&gt;
     * Marsaglia and Tsang, &lt;i&gt;A Simple Method for Generating
     * Gamma Variables.&lt;/i&gt; ACM Transactions on Mathematical Software,
     * Volume 26 Issue 3, September, 2000.&lt;/p&gt;
     *
     * @param shape the median of the Gamma distribution
     * @param scale the scale parameter of the Gamma distribution
     * @return random value sampled from the Gamma(shape, scale) distribution
     * @throws NotStrictlyPositiveException if {@code shape &lt;= 0} or
     * {@code scale &lt;= 0}.
     */
    public double nextGamma(double shape, double scale) throws NotStrictlyPositiveException {
<span class="fc" id="L422">        return new GammaDistribution(getRandomGenerator(),shape, scale,</span>
<span class="fc" id="L423">                GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();</span>
    }

    /**
     * Generates a random value from the {@link HypergeometricDistribution Hypergeometric Distribution}.
     *
     * @param populationSize the population size of the Hypergeometric distribution
     * @param numberOfSuccesses number of successes in the population of the Hypergeometric distribution
     * @param sampleSize the sample size of the Hypergeometric distribution
     * @return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution
     * @throws NumberIsTooLargeException  if {@code numberOfSuccesses &gt; populationSize},
     * or {@code sampleSize &gt; populationSize}.
     * @throws NotStrictlyPositiveException if {@code populationSize &lt;= 0}.
     * @throws NotPositiveException  if {@code numberOfSuccesses &lt; 0}.
     */
    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {
<span class="fc" id="L439">        return new HypergeometricDistribution(getRandomGenerator(),populationSize,</span>
<span class="fc" id="L440">                numberOfSuccesses, sampleSize).sample();</span>
    }

    /**
     * Generates a random value from the {@link PascalDistribution Pascal Distribution}.
     *
     * @param r the number of successes of the Pascal distribution
     * @param p the probability of success of the Pascal distribution
     * @return random value sampled from the Pascal(r, p) distribution
     * @throws NotStrictlyPositiveException if the number of successes is not positive
     * @throws OutOfRangeException if the probability of success is not in the
     * range {@code [0, 1]}.
     */
    public int nextPascal(int r, double p) throws NotStrictlyPositiveException, OutOfRangeException {
<span class="fc" id="L454">        return new PascalDistribution(getRandomGenerator(), r, p).sample();</span>
    }

    /**
     * Generates a random value from the {@link TDistribution T Distribution}.
     *
     * @param df the degrees of freedom of the T distribution
     * @return random value from the T(df) distribution
     * @throws NotStrictlyPositiveException if {@code df &lt;= 0}
     */
    public double nextT(double df) throws NotStrictlyPositiveException {
<span class="fc" id="L465">        return new TDistribution(getRandomGenerator(), df,</span>
<span class="fc" id="L466">                TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();</span>
    }

    /**
     * Generates a random value from the {@link WeibullDistribution Weibull Distribution}.
     *
     * @param shape the shape parameter of the Weibull distribution
     * @param scale the scale parameter of the Weibull distribution
     * @return random value sampled from the Weibull(shape, size) distribution
     * @throws NotStrictlyPositiveException if {@code shape &lt;= 0} or
     * {@code scale &lt;= 0}.
     */
    public double nextWeibull(double shape, double scale) throws NotStrictlyPositiveException {
<span class="fc" id="L479">        return new WeibullDistribution(getRandomGenerator(), shape, scale,</span>
<span class="fc" id="L480">                WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();</span>
    }

    /**
     * Generates a random value from the {@link ZipfDistribution Zipf Distribution}.
     *
     * @param numberOfElements the number of elements of the ZipfDistribution
     * @param exponent the exponent of the ZipfDistribution
     * @return random value sampled from the Zipf(numberOfElements, exponent) distribution
     * @exception NotStrictlyPositiveException if {@code numberOfElements &lt;= 0}
     * or {@code exponent &lt;= 0}.
     */
    public int nextZipf(int numberOfElements, double exponent) throws NotStrictlyPositiveException {
<span class="fc" id="L493">        return new ZipfDistribution(getRandomGenerator(), numberOfElements, exponent).sample();</span>
    }

    /**
     * Generates a random value from the {@link BetaDistribution Beta Distribution}.
     *
     * @param alpha first distribution shape parameter
     * @param beta second distribution shape parameter
     * @return random value sampled from the beta(alpha, beta) distribution
     */
    public double nextBeta(double alpha, double beta) {
<span class="fc" id="L504">        return new BetaDistribution(getRandomGenerator(), alpha, beta,</span>
<span class="fc" id="L505">                BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();</span>
    }

    /**
     * Generates a random value from the {@link BinomialDistribution Binomial Distribution}.
     *
     * @param numberOfTrials number of trials of the Binomial distribution
     * @param probabilityOfSuccess probability of success of the Binomial distribution
     * @return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution
     */
    public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) {
<span class="fc" id="L516">        return new BinomialDistribution(getRandomGenerator(), numberOfTrials, probabilityOfSuccess).sample();</span>
    }

    /**
     * Generates a random value from the {@link CauchyDistribution Cauchy Distribution}.
     *
     * @param median the median of the Cauchy distribution
     * @param scale the scale parameter of the Cauchy distribution
     * @return random value sampled from the Cauchy(median, scale) distribution
     */
    public double nextCauchy(double median, double scale) {
<span class="fc" id="L527">        return new CauchyDistribution(getRandomGenerator(), median, scale,</span>
<span class="fc" id="L528">                CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();</span>
    }

    /**
     * Generates a random value from the {@link ChiSquaredDistribution ChiSquare Distribution}.
     *
     * @param df the degrees of freedom of the ChiSquare distribution
     * @return random value sampled from the ChiSquare(df) distribution
     */
    public double nextChiSquare(double df) {
<span class="fc" id="L538">        return new ChiSquaredDistribution(getRandomGenerator(), df,</span>
<span class="fc" id="L539">                ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();</span>
    }

    /**
     * Generates a random value from the {@link FDistribution F Distribution}.
     *
     * @param numeratorDf the numerator degrees of freedom of the F distribution
     * @param denominatorDf the denominator degrees of freedom of the F distribution
     * @return random value sampled from the F(numeratorDf, denominatorDf) distribution
     * @throws NotStrictlyPositiveException if
     * {@code numeratorDf &lt;= 0} or {@code denominatorDf &lt;= 0}.
     */
    public double nextF(double numeratorDf, double denominatorDf) throws NotStrictlyPositiveException {
<span class="fc" id="L552">        return new FDistribution(getRandomGenerator(), numeratorDf, denominatorDf,</span>
<span class="fc" id="L553">                FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();</span>
    }

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: scales the output of
     * Random.nextDouble(), but rejects 0 values (i.e., will generate another
     * random double if Random.nextDouble() returns 0). This is necessary to
     * provide a symmetric output interval (both endpoints excluded).
     * &lt;/p&gt;
     * @throws NumberIsTooLargeException if {@code lower &gt;= upper}
     * @throws NotFiniteNumberException if one of the bounds is infinite
     * @throws NotANumberException if one of the bounds is NaN
     */
    public double nextUniform(double lower, double upper)
        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {
<span class="fc" id="L571">        return nextUniform(lower, upper, false);</span>
    }

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: if the lower bound is excluded,
     * scales the output of Random.nextDouble(), but rejects 0 values (i.e.,
     * will generate another random double if Random.nextDouble() returns 0).
     * This is necessary to provide a symmetric output interval (both
     * endpoints excluded).
     * &lt;/p&gt;
     *
     * @throws NumberIsTooLargeException if {@code lower &gt;= upper}
     * @throws NotFiniteNumberException if one of the bounds is infinite
     * @throws NotANumberException if one of the bounds is NaN
     */
    public double nextUniform(double lower, double upper, boolean lowerInclusive)
        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {

<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (lower &gt;= upper) {</span>
<span class="fc" id="L593">            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,</span>
<span class="fc" id="L594">                                                lower, upper, false);</span>
        }

<span class="fc bfc" id="L597" title="All 2 branches covered.">        if (Double.isInfinite(lower)) {</span>
<span class="fc" id="L598">            throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, lower);</span>
        }
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (Double.isInfinite(upper)) {</span>
<span class="fc" id="L601">            throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, upper);</span>
        }

<span class="fc bfc" id="L604" title="All 4 branches covered.">        if (Double.isNaN(lower) || Double.isNaN(upper)) {</span>
<span class="fc" id="L605">            throw new NotANumberException();</span>
        }

<span class="fc" id="L608">        final RandomGenerator generator = getRandomGenerator();</span>

        // ensure nextDouble() isn't 0.0
<span class="fc" id="L611">        double u = generator.nextDouble();</span>
<span class="pc bpc" id="L612" title="2 of 4 branches missed.">        while (!lowerInclusive &amp;&amp; u &lt;= 0.0) {</span>
<span class="nc" id="L613">            u = generator.nextDouble();</span>
        }

<span class="fc" id="L616">        return u * upper + (1.0 - u) * lower;</span>
    }

    /**
     * {@inheritDoc}
     *
     * This method calls {@link MathArrays#shuffle(int[],RandomGenerator)
     * MathArrays.shuffle} in order to create a random shuffle of the set
     * of natural numbers {@code { 0, 1, ..., n - 1 }}.
     *
     * @throws NumberIsTooLargeException if {@code k &gt; n}.
     * @throws NotStrictlyPositiveException if {@code k &lt;= 0}.
     */
    public int[] nextPermutation(int n, int k)
        throws NumberIsTooLargeException, NotStrictlyPositiveException {
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">        if (k &gt; n) {</span>
<span class="nc" id="L632">            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,</span>
<span class="nc" id="L633">                                                k, n, true);</span>
        }
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        if (k &lt;= 0) {</span>
<span class="nc" id="L636">            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,</span>
<span class="nc" id="L637">                                                   k);</span>
        }

<span class="fc" id="L640">        int[] index = MathArrays.natural(n);</span>
<span class="fc" id="L641">        MathArrays.shuffle(index, getRandomGenerator());</span>

        // Return a new array containing the first &quot;k&quot; entries of &quot;index&quot;.
<span class="fc" id="L644">        return MathArrays.copyOf(index, k);</span>
    }

    /**
     * {@inheritDoc}
     *
     * This method calls {@link #nextPermutation(int,int) nextPermutation(c.size(), k)}
     * in order to sample the collection.
     */
    public Object[] nextSample(Collection&lt;?&gt; c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException {

<span class="fc" id="L655">        int len = c.size();</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (k &gt; len) {</span>
<span class="fc" id="L657">            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,</span>
<span class="fc" id="L658">                                                k, len, true);</span>
        }
<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (k &lt;= 0) {</span>
<span class="fc" id="L661">            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);</span>
        }

<span class="fc" id="L664">        Object[] objects = c.toArray();</span>
<span class="fc" id="L665">        int[] index = nextPermutation(len, k);</span>
<span class="fc" id="L666">        Object[] result = new Object[k];</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">        for (int i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L668">            result[i] = objects[index[i]];</span>
        }
<span class="fc" id="L670">        return result;</span>
    }



    /**
     * Reseeds the random number generator with the supplied seed.
     * &lt;p&gt;
     * Will create and initialize if null.
     * &lt;/p&gt;
     *
     * @param seed the seed value to use
     */
    public void reSeed(long seed) {
<span class="fc" id="L684">       getRandomGenerator().setSeed(seed);</span>
<span class="fc" id="L685">    }</span>

    /**
     * Reseeds the secure random number generator with the current time in
     * milliseconds.
     * &lt;p&gt;
     * Will create and initialize if null.
     * &lt;/p&gt;
     */
    public void reSeedSecure() {
<span class="fc" id="L695">        getSecRan().setSeed(System.currentTimeMillis());</span>
<span class="fc" id="L696">    }</span>

    /**
     * Reseeds the secure random number generator with the supplied seed.
     * &lt;p&gt;
     * Will create and initialize if null.
     * &lt;/p&gt;
     *
     * @param seed the seed value to use
     */
    public void reSeedSecure(long seed) {
<span class="fc" id="L707">        getSecRan().setSeed(seed);</span>
<span class="fc" id="L708">    }</span>

    /**
     * Reseeds the random number generator with
     * {@code System.currentTimeMillis() + System.identityHashCode(this))}.
     */
    public void reSeed() {
<span class="fc" id="L715">        getRandomGenerator().setSeed(System.currentTimeMillis() + System.identityHashCode(this));</span>
<span class="fc" id="L716">    }</span>

    /**
     * Sets the PRNG algorithm for the underlying SecureRandom instance using
     * the Security Provider API. The Security Provider API is defined in &lt;a
     * href =
     * &quot;http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA&quot;&gt;
     * Java Cryptography Architecture API Specification &amp; Reference.&lt;/a&gt;
     * &lt;p&gt;
     * &lt;strong&gt;USAGE NOTE:&lt;/strong&gt; This method carries &lt;i&gt;significant&lt;/i&gt;
     * overhead and may take several seconds to execute.
     * &lt;/p&gt;
     *
     * @param algorithm the name of the PRNG algorithm
     * @param provider the name of the provider
     * @throws NoSuchAlgorithmException if the specified algorithm is not available
     * @throws NoSuchProviderException if the specified provider is not installed
     */
    public void setSecureAlgorithm(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
<span class="nc" id="L736">        secRand = RandomGeneratorFactory.createRandomGenerator(SecureRandom.getInstance(algorithm, provider));</span>
<span class="nc" id="L737">    }</span>

    /**
     * Returns the RandomGenerator used to generate non-secure random data.
     * &lt;p&gt;
     * Creates and initializes a default generator if null. Uses a {@link Well19937c}
     * generator with {@code System.currentTimeMillis() + System.identityHashCode(this))}
     * as the default seed.
     * &lt;/p&gt;
     *
     * @return the Random used to generate random data
     * @since 3.2
     */
    public RandomGenerator getRandomGenerator() {
<span class="fc bfc" id="L751" title="All 2 branches covered.">        if (rand == null) {</span>
<span class="fc" id="L752">            initRan();</span>
        }
<span class="fc" id="L754">        return rand;</span>
    }

    /**
     * Sets the default generator to a {@link Well19937c} generator seeded with
     * {@code System.currentTimeMillis() + System.identityHashCode(this))}.
     */
    private void initRan() {
<span class="fc" id="L762">        rand = new Well19937c(System.currentTimeMillis() + System.identityHashCode(this));</span>
<span class="fc" id="L763">    }</span>

    /**
     * Returns the SecureRandom used to generate secure random data.
     * &lt;p&gt;
     * Creates and initializes if null.  Uses
     * {@code System.currentTimeMillis() + System.identityHashCode(this)} as the default seed.
     * &lt;/p&gt;
     *
     * @return the SecureRandom used to generate secure random data, wrapped in a
     * {@link RandomGenerator}.
     */
    private RandomGenerator getSecRan() {
<span class="fc bfc" id="L776" title="All 2 branches covered.">        if (secRand == null) {</span>
<span class="fc" id="L777">            secRand = RandomGeneratorFactory.createRandomGenerator(new SecureRandom());</span>
<span class="fc" id="L778">            secRand.setSeed(System.currentTimeMillis() + System.identityHashCode(this));</span>
        }
<span class="fc" id="L780">        return secRand;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>