<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CMAESOptimizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.optimization.direct</a> &gt; <span class="el_source">CMAESOptimizer.java</span></div><h1>CMAESOptimizer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math3.optimization.direct;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.math3.analysis.MultivariateFunction;
import org.apache.commons.math3.exception.DimensionMismatchException;
import org.apache.commons.math3.exception.NotPositiveException;
import org.apache.commons.math3.exception.NotStrictlyPositiveException;
import org.apache.commons.math3.exception.OutOfRangeException;
import org.apache.commons.math3.exception.TooManyEvaluationsException;
import org.apache.commons.math3.linear.Array2DRowRealMatrix;
import org.apache.commons.math3.linear.EigenDecomposition;
import org.apache.commons.math3.linear.MatrixUtils;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.optimization.ConvergenceChecker;
import org.apache.commons.math3.optimization.OptimizationData;
import org.apache.commons.math3.optimization.GoalType;
import org.apache.commons.math3.optimization.MultivariateOptimizer;
import org.apache.commons.math3.optimization.PointValuePair;
import org.apache.commons.math3.optimization.SimpleValueChecker;
import org.apache.commons.math3.random.MersenneTwister;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.util.FastMath;
import org.apache.commons.math3.util.MathArrays;

/**
 * &lt;p&gt;An implementation of the active Covariance Matrix Adaptation Evolution Strategy (CMA-ES)
 * for non-linear, non-convex, non-smooth, global function minimization.
 * The CMA-Evolution Strategy (CMA-ES) is a reliable stochastic optimization method
 * which should be applied if derivative-based methods, e.g. quasi-Newton BFGS or
 * conjugate gradient, fail due to a rugged search landscape (e.g. noise, local
 * optima, outlier, etc.) of the objective function. Like a
 * quasi-Newton method, the CMA-ES learns and applies a variable metric
 * on the underlying search space. Unlike a quasi-Newton method, the
 * CMA-ES neither estimates nor uses gradients, making it considerably more
 * reliable in terms of finding a good, or even close to optimal, solution.&lt;/p&gt;
 *
 * &lt;p&gt;In general, on smooth objective functions the CMA-ES is roughly ten times
 * slower than BFGS (counting objective function evaluations, no gradients provided).
 * For up to &lt;math&gt;N=10&lt;/math&gt; variables also the derivative-free simplex
 * direct search method (Nelder and Mead) can be faster, but it is
 * far less reliable than CMA-ES.&lt;/p&gt;
 *
 * &lt;p&gt;The CMA-ES is particularly well suited for non-separable
 * and/or badly conditioned problems. To observe the advantage of CMA compared
 * to a conventional evolution strategy, it will usually take about
 * &lt;math&gt;30 N&lt;/math&gt; function evaluations. On difficult problems the complete
 * optimization (a single run) is expected to take &lt;em&gt;roughly&lt;/em&gt; between
 * &lt;math&gt;30 N&lt;/math&gt; and &lt;math&gt;300 N&lt;sup&gt;2&lt;/sup&gt;&lt;/math&gt;
 * function evaluations.&lt;/p&gt;
 *
 * &lt;p&gt;This implementation is translated and adapted from the Matlab version
 * of the CMA-ES algorithm as implemented in module {@code cmaes.m} version 3.51.&lt;/p&gt;
 *
 * For more information, please refer to the following links:
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;a href=&quot;http://www.lri.fr/~hansen/cmaes.m&quot;&gt;Matlab code&lt;/a&gt;&lt;/li&gt;
 *  &lt;li&gt;&lt;a href=&quot;http://www.lri.fr/~hansen/cmaesintro.html&quot;&gt;Introduction to CMA-ES&lt;/a&gt;&lt;/li&gt;
 *  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/CMA-ES&quot;&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @deprecated As of 3.1 (to be removed in 4.0).
 * @since 3.0
 */
@Deprecated
public class CMAESOptimizer
    extends BaseAbstractMultivariateSimpleBoundsOptimizer&lt;MultivariateFunction&gt;
    implements MultivariateOptimizer {
    /** Default value for {@link #checkFeasableCount}: {@value}. */
    public static final int DEFAULT_CHECKFEASABLECOUNT = 0;
    /** Default value for {@link #stopFitness}: {@value}. */
    public static final double DEFAULT_STOPFITNESS = 0;
    /** Default value for {@link #isActiveCMA}: {@value}. */
    public static final boolean DEFAULT_ISACTIVECMA = true;
    /** Default value for {@link #maxIterations}: {@value}. */
    public static final int DEFAULT_MAXITERATIONS = 30000;
    /** Default value for {@link #diagonalOnly}: {@value}. */
    public static final int DEFAULT_DIAGONALONLY = 0;
    /** Default value for {@link #random}. */
<span class="fc" id="L99">    public static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();</span>

    // global search parameters
    /**
     * Population size, offspring number. The primary strategy parameter to play
     * with, which can be increased from its default value. Increasing the
     * population size improves global search properties in exchange to speed.
     * Speed decreases, as a rule, at most linearly with increasing population
     * size. It is advisable to begin with the default small population size.
     */
    private int lambda; // population size
    /**
     * Covariance update mechanism, default is active CMA. isActiveCMA = true
     * turns on &quot;active CMA&quot; with a negative update of the covariance matrix and
     * checks for positive definiteness. OPTS.CMA.active = 2 does not check for
     * pos. def. and is numerically faster. Active CMA usually speeds up the
     * adaptation.
     */
    private boolean isActiveCMA;
    /**
     * Determines how often a new random offspring is generated in case it is
     * not feasible / beyond the defined limits, default is 0.
     */
    private int checkFeasableCount;
    /**
     * @see Sigma
     */
    private double[] inputSigma;
    /** Number of objective variables/problem dimension */
    private int dimension;
    /**
     * Defines the number of initial iterations, where the covariance matrix
     * remains diagonal and the algorithm has internally linear time complexity.
     * diagonalOnly = 1 means keeping the covariance matrix always diagonal and
     * this setting also exhibits linear space complexity. This can be
     * particularly useful for dimension &gt; 100.
     * @see &lt;a href=&quot;http://hal.archives-ouvertes.fr/inria-00287367/en&quot;&gt;A Simple Modification in CMA-ES&lt;/a&gt;
     */
<span class="fc" id="L137">    private int diagonalOnly = 0;</span>
    /** Number of objective variables/problem dimension */
<span class="fc" id="L139">    private boolean isMinimize = true;</span>
    /** Indicates whether statistic data is collected. */
<span class="fc" id="L141">    private boolean generateStatistics = false;</span>

    // termination criteria
    /** Maximal number of iterations allowed. */
    private int maxIterations;
    /** Limit for fitness value. */
    private double stopFitness;
    /** Stop if x-changes larger stopTolUpX. */
    private double stopTolUpX;
    /** Stop if x-change smaller stopTolX. */
    private double stopTolX;
    /** Stop if fun-changes smaller stopTolFun. */
    private double stopTolFun;
    /** Stop if back fun-changes smaller stopTolHistFun. */
    private double stopTolHistFun;

    // selection strategy parameters
    /** Number of parents/points for recombination. */
    private int mu; //
    /** log(mu + 0.5), stored for efficiency. */
    private double logMu2;
    /** Array for weighted recombination. */
    private RealMatrix weights;
    /** Variance-effectiveness of sum w_i x_i. */
    private double mueff; //

    // dynamic strategy parameters and constants
    /** Overall standard deviation - search volume. */
    private double sigma;
    /** Cumulation constant. */
    private double cc;
    /** Cumulation constant for step-size. */
    private double cs;
    /** Damping for step-size. */
    private double damps;
    /** Learning rate for rank-one update. */
    private double ccov1;
    /** Learning rate for rank-mu update' */
    private double ccovmu;
    /** Expectation of ||N(0,I)|| == norm(randn(N,1)). */
    private double chiN;
    /** Learning rate for rank-one update - diagonalOnly */
    private double ccov1Sep;
    /** Learning rate for rank-mu update - diagonalOnly */
    private double ccovmuSep;

    // CMA internal values - updated each generation
    /** Objective variables. */
    private RealMatrix xmean;
    /** Evolution path. */
    private RealMatrix pc;
    /** Evolution path for sigma. */
    private RealMatrix ps;
    /** Norm of ps, stored for efficiency. */
    private double normps;
    /** Coordinate system. */
    private RealMatrix B;
    /** Scaling. */
    private RealMatrix D;
    /** B*D, stored for efficiency. */
    private RealMatrix BD;
    /** Diagonal of sqrt(D), stored for efficiency. */
    private RealMatrix diagD;
    /** Covariance matrix. */
    private RealMatrix C;
    /** Diagonal of C, used for diagonalOnly. */
    private RealMatrix diagC;
    /** Number of iterations already performed. */
    private int iterations;

    /** History queue of best values. */
    private double[] fitnessHistory;
    /** Size of history queue of best values. */
    private int historySize;

    /** Random generator. */
    private RandomGenerator random;

    /** History of sigma values. */
<span class="fc" id="L220">    private List&lt;Double&gt; statisticsSigmaHistory = new ArrayList&lt;Double&gt;();</span>
    /** History of mean matrix. */
<span class="fc" id="L222">    private List&lt;RealMatrix&gt; statisticsMeanHistory = new ArrayList&lt;RealMatrix&gt;();</span>
    /** History of fitness values. */
<span class="fc" id="L224">    private List&lt;Double&gt; statisticsFitnessHistory = new ArrayList&lt;Double&gt;();</span>
    /** History of D matrix. */
<span class="fc" id="L226">    private List&lt;RealMatrix&gt; statisticsDHistory = new ArrayList&lt;RealMatrix&gt;();</span>

    /**
     * Default constructor, uses default parameters
     *
     * @deprecated As of version 3.1: Parameter {@code lambda} must be
     * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])
     * optimize} (whereas in the current code it is set to an undocumented value).
     */
    @Deprecated
    public CMAESOptimizer() {
<span class="fc" id="L237">        this(0);</span>
<span class="fc" id="L238">    }</span>

    /**
     * @param lambda Population size.
     * @deprecated As of version 3.1: Parameter {@code lambda} must be
     * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])
     * optimize} (whereas in the current code it is set to an undocumented value)..
     */
    @Deprecated
    public CMAESOptimizer(int lambda) {
<span class="fc" id="L248">        this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,</span>
<span class="fc" id="L249">             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,</span>
<span class="fc" id="L250">             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR,</span>
<span class="fc" id="L251">             false, null);</span>
<span class="fc" id="L252">    }</span>

    /**
     * @param lambda Population size.
     * @param inputSigma Initial standard deviations to sample new points
     * around the initial guess.
     * @deprecated As of version 3.1: Parameters {@code lambda} and {@code inputSigma} must be
     * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])
     * optimize}.
     */
    @Deprecated
    public CMAESOptimizer(int lambda, double[] inputSigma) {
<span class="nc" id="L264">        this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,</span>
<span class="nc" id="L265">             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,</span>
<span class="nc" id="L266">             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);</span>
<span class="nc" id="L267">    }</span>

    /**
     * @param lambda Population size.
     * @param inputSigma Initial standard deviations to sample new points
     * around the initial guess.
     * @param maxIterations Maximal number of iterations.
     * @param stopFitness Whether to stop if objective function value is smaller than
     * {@code stopFitness}.
     * @param isActiveCMA Chooses the covariance matrix update method.
     * @param diagonalOnly Number of initial iterations, where the covariance matrix
     * remains diagonal.
     * @param checkFeasableCount Determines how often new random objective variables are
     * generated in case they are out of bounds.
     * @param random Random generator.
     * @param generateStatistics Whether statistic data is collected.
     * @deprecated See {@link SimpleValueChecker#SimpleValueChecker()}
     */
    @Deprecated
    public CMAESOptimizer(int lambda, double[] inputSigma,
                          int maxIterations, double stopFitness,
                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,
                          RandomGenerator random, boolean generateStatistics) {
<span class="nc" id="L290">        this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,</span>
<span class="nc" id="L291">             diagonalOnly, checkFeasableCount, random, generateStatistics,</span>
<span class="nc" id="L292">             new SimpleValueChecker());</span>
<span class="nc" id="L293">    }</span>

    /**
     * @param lambda Population size.
     * @param inputSigma Initial standard deviations to sample new points
     * around the initial guess.
     * @param maxIterations Maximal number of iterations.
     * @param stopFitness Whether to stop if objective function value is smaller than
     * {@code stopFitness}.
     * @param isActiveCMA Chooses the covariance matrix update method.
     * @param diagonalOnly Number of initial iterations, where the covariance matrix
     * remains diagonal.
     * @param checkFeasableCount Determines how often new random objective variables are
     * generated in case they are out of bounds.
     * @param random Random generator.
     * @param generateStatistics Whether statistic data is collected.
     * @param checker Convergence checker.
     * @deprecated As of version 3.1: Parameters {@code lambda} and {@code inputSigma} must be
     * passed with the call to {@link #optimize(int,MultivariateFunction,GoalType,OptimizationData[])
     * optimize}.
     */
    @Deprecated
    public CMAESOptimizer(int lambda, double[] inputSigma,
                          int maxIterations, double stopFitness,
                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,
                          RandomGenerator random, boolean generateStatistics,
                          ConvergenceChecker&lt;PointValuePair&gt; checker) {
<span class="fc" id="L320">        super(checker);</span>
<span class="fc" id="L321">        this.lambda = lambda;</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();</span>
<span class="fc" id="L323">        this.maxIterations = maxIterations;</span>
<span class="fc" id="L324">        this.stopFitness = stopFitness;</span>
<span class="fc" id="L325">        this.isActiveCMA = isActiveCMA;</span>
<span class="fc" id="L326">        this.diagonalOnly = diagonalOnly;</span>
<span class="fc" id="L327">        this.checkFeasableCount = checkFeasableCount;</span>
<span class="fc" id="L328">        this.random = random;</span>
<span class="fc" id="L329">        this.generateStatistics = generateStatistics;</span>
<span class="fc" id="L330">    }</span>

    /**
     * @param maxIterations Maximal number of iterations.
     * @param stopFitness Whether to stop if objective function value is smaller than
     * {@code stopFitness}.
     * @param isActiveCMA Chooses the covariance matrix update method.
     * @param diagonalOnly Number of initial iterations, where the covariance matrix
     * remains diagonal.
     * @param checkFeasableCount Determines how often new random objective variables are
     * generated in case they are out of bounds.
     * @param random Random generator.
     * @param generateStatistics Whether statistic data is collected.
     * @param checker Convergence checker.
     *
     * @since 3.1
     */
    public CMAESOptimizer(int maxIterations,
                          double stopFitness,
                          boolean isActiveCMA,
                          int diagonalOnly,
                          int checkFeasableCount,
                          RandomGenerator random,
                          boolean generateStatistics,
                          ConvergenceChecker&lt;PointValuePair&gt; checker) {
<span class="fc" id="L355">        super(checker);</span>
<span class="fc" id="L356">        this.maxIterations = maxIterations;</span>
<span class="fc" id="L357">        this.stopFitness = stopFitness;</span>
<span class="fc" id="L358">        this.isActiveCMA = isActiveCMA;</span>
<span class="fc" id="L359">        this.diagonalOnly = diagonalOnly;</span>
<span class="fc" id="L360">        this.checkFeasableCount = checkFeasableCount;</span>
<span class="fc" id="L361">        this.random = random;</span>
<span class="fc" id="L362">        this.generateStatistics = generateStatistics;</span>
<span class="fc" id="L363">    }</span>

    /**
     * @return History of sigma values.
     */
    public List&lt;Double&gt; getStatisticsSigmaHistory() {
<span class="nc" id="L369">        return statisticsSigmaHistory;</span>
    }

    /**
     * @return History of mean matrix.
     */
    public List&lt;RealMatrix&gt; getStatisticsMeanHistory() {
<span class="nc" id="L376">        return statisticsMeanHistory;</span>
    }

    /**
     * @return History of fitness values.
     */
    public List&lt;Double&gt; getStatisticsFitnessHistory() {
<span class="nc" id="L383">        return statisticsFitnessHistory;</span>
    }

    /**
     * @return History of D matrix.
     */
    public List&lt;RealMatrix&gt; getStatisticsDHistory() {
<span class="nc" id="L390">        return statisticsDHistory;</span>
    }

    /**
     * Input sigma values.
     * They define the initial coordinate-wise standard deviations for
     * sampling new search points around the initial guess.
     * It is suggested to set them to the estimated distance from the
     * initial to the desired optimum.
     * Small values induce the search to be more local (and very small
     * values are more likely to find a local optimum close to the initial
     * guess).
     * Too small values might however lead to early termination.
     * @since 3.1
     */
    public static class Sigma implements OptimizationData {
        /** Sigma values. */
        private final double[] sigma;

        /**
         * @param s Sigma values.
         * @throws NotPositiveException if any of the array entries is smaller
         * than zero.
         */
<span class="fc" id="L414">        public Sigma(double[] s)</span>
            throws NotPositiveException {
<span class="fc bfc" id="L416" title="All 2 branches covered.">            for (int i = 0; i &lt; s.length; i++) {</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">                if (s[i] &lt; 0) {</span>
<span class="fc" id="L418">                    throw new NotPositiveException(s[i]);</span>
                }
            }

<span class="fc" id="L422">            sigma = s.clone();</span>
<span class="fc" id="L423">        }</span>

        /**
         * @return the sigma values.
         */
        public double[] getSigma() {
<span class="fc" id="L429">            return sigma.clone();</span>
        }
    }

    /**
     * Population size.
     * The number of offspring is the primary strategy parameter.
     * In the absence of better clues, a good default could be an
     * integer close to {@code 4 + 3 ln(n)}, where {@code n} is the
     * number of optimized parameters.
     * Increasing the population size improves global search properties
     * at the expense of speed (which in general decreases at most
     * linearly with increasing population size).
     * @since 3.1
     */
    public static class PopulationSize implements OptimizationData {
        /** Population size. */
        private final int lambda;

        /**
         * @param size Population size.
         * @throws NotStrictlyPositiveException if {@code size &lt;= 0}.
         */
<span class="fc" id="L452">        public PopulationSize(int size)</span>
            throws NotStrictlyPositiveException {
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">            if (size &lt;= 0) {</span>
<span class="nc" id="L455">                throw new NotStrictlyPositiveException(size);</span>
            }
<span class="fc" id="L457">            lambda = size;</span>
<span class="fc" id="L458">        }</span>

        /**
         * @return the population size.
         */
        public int getPopulationSize() {
<span class="fc" id="L464">            return lambda;</span>
        }
    }

    /**
     * Optimize an objective function.
     *
     * @param maxEval Allowed number of evaluations of the objective function.
     * @param f Objective function.
     * @param goalType Optimization type.
     * @param optData Optimization data. The following data will be looked for:
     * &lt;ul&gt;
     *  &lt;li&gt;{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}&lt;/li&gt;
     *  &lt;li&gt;{@link Sigma}&lt;/li&gt;
     *  &lt;li&gt;{@link PopulationSize}&lt;/li&gt;
     * &lt;/ul&gt;
     * @return the point/value pair giving the optimal value for objective
     * function.
     */
    @Override
    protected PointValuePair optimizeInternal(int maxEval, MultivariateFunction f,
                                              GoalType goalType,
                                              OptimizationData... optData) {
        // Scan &quot;optData&quot; for the input specific to this optimizer.
<span class="fc" id="L488">        parseOptimizationData(optData);</span>

        // The parent's method will retrieve the common parameters from
        // &quot;optData&quot; and call &quot;doOptimize&quot;.
<span class="fc" id="L492">        return super.optimizeInternal(maxEval, f, goalType, optData);</span>
    }

    /** {@inheritDoc} */
    @Override
    protected PointValuePair doOptimize() {
<span class="fc" id="L498">        checkParameters();</span>
         // -------------------- Initialization --------------------------------
<span class="fc" id="L500">        isMinimize = getGoalType().equals(GoalType.MINIMIZE);</span>
<span class="fc" id="L501">        final FitnessFunction fitfun = new FitnessFunction();</span>
<span class="fc" id="L502">        final double[] guess = getStartPoint();</span>
        // number of objective variables/problem dimension
<span class="fc" id="L504">        dimension = guess.length;</span>
<span class="fc" id="L505">        initializeCMA(guess);</span>
<span class="fc" id="L506">        iterations = 0;</span>
<span class="fc" id="L507">        double bestValue = fitfun.value(guess);</span>
<span class="fc" id="L508">        push(fitnessHistory, bestValue);</span>
<span class="fc" id="L509">        PointValuePair optimum = new PointValuePair(getStartPoint(),</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">                isMinimize ? bestValue : -bestValue);</span>
<span class="fc" id="L511">        PointValuePair lastResult = null;</span>

        // -------------------- Generation Loop --------------------------------

        generationLoop:
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        for (iterations = 1; iterations &lt;= maxIterations; iterations++) {</span>
            // Generate and evaluate lambda offspring
<span class="fc" id="L518">            final RealMatrix arz = randn1(dimension, lambda);</span>
<span class="fc" id="L519">            final RealMatrix arx = zeros(dimension, lambda);</span>
<span class="fc" id="L520">            final double[] fitness = new double[lambda];</span>
            // generate random offspring
<span class="fc bfc" id="L522" title="All 2 branches covered.">            for (int k = 0; k &lt; lambda; k++) {</span>
<span class="fc" id="L523">                RealMatrix arxk = null;</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">                for (int i = 0; i &lt; checkFeasableCount + 1; i++) {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                    if (diagonalOnly &lt;= 0) {</span>
<span class="fc" id="L526">                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))</span>
<span class="fc" id="L527">                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)</span>
<span class="fc" id="L528">                    } else {</span>
<span class="fc" id="L529">                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))</span>
<span class="fc" id="L530">                                         .scalarMultiply(sigma));</span>
                    }
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">                    if (i &gt;= checkFeasableCount ||</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                        fitfun.isFeasible(arxk.getColumn(0))) {</span>
<span class="nc" id="L534">                        break;</span>
                    }
                    // regenerate random arguments for row
<span class="nc" id="L537">                    arz.setColumn(k, randn(dimension));</span>
                }
<span class="fc" id="L539">                copyColumn(arxk, 0, arx, k);</span>
                try {
<span class="fc" id="L541">                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness</span>
<span class="pc" id="L542">                } catch (TooManyEvaluationsException e) {</span>
<span class="nc" id="L543">                    break generationLoop;</span>
                }
            }
            // Sort by fitness and compute weighted mean into xmean
<span class="fc" id="L547">            final int[] arindex = sortedIndices(fitness);</span>
            // Calculate new xmean, this is selection and recombination
<span class="fc" id="L549">            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)</span>
<span class="fc" id="L550">            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));</span>
<span class="fc" id="L551">            xmean = bestArx.multiply(weights);</span>
<span class="fc" id="L552">            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));</span>
<span class="fc" id="L553">            final RealMatrix zmean = bestArz.multiply(weights);</span>
<span class="fc" id="L554">            final boolean hsig = updateEvolutionPaths(zmean, xold);</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">            if (diagonalOnly &lt;= 0) {</span>
<span class="fc" id="L556">                updateCovariance(hsig, bestArx, arz, arindex, xold);</span>
<span class="fc" id="L557">            } else {</span>
<span class="fc" id="L558">                updateCovarianceDiagonalOnly(hsig, bestArz);</span>
            }
            // Adapt step size sigma - Eq. (5)
<span class="fc" id="L561">            sigma *= FastMath.exp(FastMath.min(1, (normps/chiN - 1) * cs / damps));</span>
<span class="fc" id="L562">            final double bestFitness = fitness[arindex[0]];</span>
<span class="fc" id="L563">            final double worstFitness = fitness[arindex[arindex.length - 1]];</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">            if (bestValue &gt; bestFitness) {</span>
<span class="fc" id="L565">                bestValue = bestFitness;</span>
<span class="fc" id="L566">                lastResult = optimum;</span>
<span class="fc" id="L567">                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                                             isMinimize ? bestFitness : -bestFitness);</span>
<span class="pc bpc" id="L569" title="3 of 4 branches missed.">                if (getConvergenceChecker() != null &amp;&amp; lastResult != null &amp;&amp;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                    getConvergenceChecker().converged(iterations, optimum, lastResult)) {</span>
<span class="nc" id="L571">                    break generationLoop;</span>
                }
            }
            // handle termination criteria
            // Break, if fitness is good enough
<span class="fc bfc" id="L576" title="All 6 branches covered.">            if (stopFitness != 0 &amp;&amp; bestFitness &lt; (isMinimize ? stopFitness : -stopFitness)) {</span>
<span class="fc" id="L577">                break generationLoop;</span>
            }
<span class="fc" id="L579">            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);</span>
<span class="fc" id="L580">            final double[] pcCol = pc.getColumn(0);</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">            for (int i = 0; i &lt; dimension; i++) {</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">                if (sigma * FastMath.max(FastMath.abs(pcCol[i]), sqrtDiagC[i]) &gt; stopTolX) {</span>
<span class="fc" id="L583">                    break;</span>
                }
<span class="fc bfc" id="L585" title="All 2 branches covered.">                if (i &gt;= dimension - 1) {</span>
<span class="fc" id="L586">                    break generationLoop;</span>
                }
            }
<span class="fc bfc" id="L589" title="All 2 branches covered.">            for (int i = 0; i &lt; dimension; i++) {</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">                if (sigma * sqrtDiagC[i] &gt; stopTolUpX) {</span>
<span class="nc" id="L591">                    break generationLoop;</span>
                }
            }
<span class="fc" id="L594">            final double historyBest = min(fitnessHistory);</span>
<span class="fc" id="L595">            final double historyWorst = max(fitnessHistory);</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            if (iterations &gt; 2 &amp;&amp;</span>
<span class="fc" id="L597">                FastMath.max(historyWorst, worstFitness) -</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">                FastMath.min(historyBest, bestFitness) &lt; stopTolFun) {</span>
<span class="fc" id="L599">                break generationLoop;</span>
            }
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (iterations &gt; fitnessHistory.length &amp;&amp;</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">                historyWorst-historyBest &lt; stopTolHistFun) {</span>
<span class="nc" id="L603">                break generationLoop;</span>
            }
            // condition number of the covariance matrix exceeds 1e14
<span class="fc bfc" id="L606" title="All 2 branches covered.">            if (max(diagD)/min(diagD) &gt; 1e7) {</span>
<span class="fc" id="L607">                break generationLoop;</span>
            }
            // user defined termination
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">            if (getConvergenceChecker() != null) {</span>
<span class="nc" id="L611">                final PointValuePair current</span>
<span class="nc" id="L612">                    = new PointValuePair(bestArx.getColumn(0),</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                                         isMinimize ? bestFitness : -bestFitness);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                if (lastResult != null &amp;&amp;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">                    getConvergenceChecker().converged(iterations, current, lastResult)) {</span>
<span class="nc" id="L616">                    break generationLoop;</span>
                    }
<span class="nc" id="L618">                lastResult = current;</span>
            }
            // Adjust step size in case of equal function values (flat fitness)
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {</span>
<span class="nc" id="L622">                sigma *= FastMath.exp(0.2 + cs / damps);</span>
            }
<span class="fc bfc" id="L624" title="All 2 branches covered.">            if (iterations &gt; 2 &amp;&amp; FastMath.max(historyWorst, bestFitness) -</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">                FastMath.min(historyBest, bestFitness) == 0) {</span>
<span class="nc" id="L626">                sigma *= FastMath.exp(0.2 + cs / damps);</span>
            }
            // store best in history
<span class="fc" id="L629">            push(fitnessHistory,bestFitness);</span>
<span class="fc" id="L630">            fitfun.setValueRange(worstFitness-bestFitness);</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">            if (generateStatistics) {</span>
<span class="nc" id="L632">                statisticsSigmaHistory.add(sigma);</span>
<span class="nc" id="L633">                statisticsFitnessHistory.add(bestFitness);</span>
<span class="nc" id="L634">                statisticsMeanHistory.add(xmean.transpose());</span>
<span class="nc" id="L635">                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));</span>
            }
        }
<span class="fc" id="L638">        return optimum;</span>
    }

    /**
     * Scans the list of (required and optional) optimization data that
     * characterize the problem.
     *
     * @param optData Optimization data. The following data will be looked for:
     * &lt;ul&gt;
     *  &lt;li&gt;{@link Sigma}&lt;/li&gt;
     *  &lt;li&gt;{@link PopulationSize}&lt;/li&gt;
     * &lt;/ul&gt;
     */
    private void parseOptimizationData(OptimizationData... optData) {
        // The existing values (as set by the previous call) are reused if
        // not provided in the argument list.
<span class="fc bfc" id="L654" title="All 2 branches covered.">        for (OptimizationData data : optData) {</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">            if (data instanceof Sigma) {</span>
<span class="fc" id="L656">                inputSigma = ((Sigma) data).getSigma();</span>
<span class="fc" id="L657">                continue;</span>
            }
<span class="fc bfc" id="L659" title="All 2 branches covered.">            if (data instanceof PopulationSize) {</span>
<span class="fc" id="L660">                lambda = ((PopulationSize) data).getPopulationSize();</span>
                continue;
            }
        }
<span class="fc" id="L664">    }</span>

    /**
     * Checks dimensions and values of boundaries and inputSigma if defined.
     */
    private void checkParameters() {
<span class="fc" id="L670">        final double[] init = getStartPoint();</span>
<span class="fc" id="L671">        final double[] lB = getLowerBound();</span>
<span class="fc" id="L672">        final double[] uB = getUpperBound();</span>

<span class="fc bfc" id="L674" title="All 2 branches covered.">        if (inputSigma != null) {</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (inputSigma.length != init.length) {</span>
<span class="fc" id="L676">                throw new DimensionMismatchException(inputSigma.length, init.length);</span>
            }
<span class="fc bfc" id="L678" title="All 2 branches covered.">            for (int i = 0; i &lt; init.length; i++) {</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">                if (inputSigma[i] &lt; 0) {</span>
                    // XXX Remove this block in 4.0 (check performed in &quot;Sigma&quot; class).
<span class="nc" id="L681">                    throw new NotPositiveException(inputSigma[i]);</span>
                }
<span class="fc bfc" id="L683" title="All 2 branches covered.">                if (inputSigma[i] &gt; uB[i] - lB[i]) {</span>
<span class="fc" id="L684">                    throw new OutOfRangeException(inputSigma[i], 0, uB[i] - lB[i]);</span>
                }
            }
        }
<span class="fc" id="L688">    }</span>

    /**
     * Initialization of the dynamic search parameters
     *
     * @param guess Initial guess for the arguments of the fitness function.
     */
    private void initializeCMA(double[] guess) {
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (lambda &lt;= 0) {</span>
            // XXX Line below to replace the current one in 4.0 (MATH-879).
            // throw new NotStrictlyPositiveException(lambda);
<span class="fc" id="L699">            lambda = 4 + (int) (3 * FastMath.log(dimension));</span>
        }
        // initialize sigma
<span class="fc" id="L702">        final double[][] sigmaArray = new double[guess.length][1];</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">        for (int i = 0; i &lt; guess.length; i++) {</span>
            // XXX Line below to replace the current one in 4.0 (MATH-868).
            // sigmaArray[i][0] = inputSigma[i];
<span class="fc bfc" id="L706" title="All 2 branches covered.">            sigmaArray[i][0] = inputSigma == null ? 0.3 : inputSigma[i];</span>
        }
<span class="fc" id="L708">        final RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);</span>
<span class="fc" id="L709">        sigma = max(insigma); // overall standard deviation</span>

        // initialize termination criteria
<span class="fc" id="L712">        stopTolUpX = 1e3 * max(insigma);</span>
<span class="fc" id="L713">        stopTolX = 1e-11 * max(insigma);</span>
<span class="fc" id="L714">        stopTolFun = 1e-12;</span>
<span class="fc" id="L715">        stopTolHistFun = 1e-13;</span>

        // initialize selection strategy parameters
<span class="fc" id="L718">        mu = lambda / 2; // number of parents/points for recombination</span>
<span class="fc" id="L719">        logMu2 = FastMath.log(mu + 0.5);</span>
<span class="fc" id="L720">        weights = log(sequence(1, mu, 1)).scalarMultiply(-1).scalarAdd(logMu2);</span>
<span class="fc" id="L721">        double sumw = 0;</span>
<span class="fc" id="L722">        double sumwq = 0;</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        for (int i = 0; i &lt; mu; i++) {</span>
<span class="fc" id="L724">            double w = weights.getEntry(i, 0);</span>
<span class="fc" id="L725">            sumw += w;</span>
<span class="fc" id="L726">            sumwq += w * w;</span>
        }
<span class="fc" id="L728">        weights = weights.scalarMultiply(1 / sumw);</span>
<span class="fc" id="L729">        mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i</span>

        // initialize dynamic strategy parameters and constants
<span class="fc" id="L732">        cc = (4 + mueff / dimension) /</span>
<span class="fc" id="L733">                (dimension + 4 + 2 * mueff / dimension);</span>
<span class="fc" id="L734">        cs = (mueff + 2) / (dimension + mueff + 3.);</span>
<span class="fc" id="L735">        damps = (1 + 2 * FastMath.max(0, FastMath.sqrt((mueff - 1) /</span>
<span class="fc" id="L736">                                                       (dimension + 1)) - 1)) *</span>
<span class="fc" id="L737">            FastMath.max(0.3,</span>
<span class="fc" id="L738">                         1 - dimension / (1e-6 + maxIterations)) + cs; // minor increment</span>
<span class="fc" id="L739">        ccov1 = 2 / ((dimension + 1.3) * (dimension + 1.3) + mueff);</span>
<span class="fc" id="L740">        ccovmu = FastMath.min(1 - ccov1, 2 * (mueff - 2 + 1 / mueff) /</span>
<span class="fc" id="L741">                              ((dimension + 2) * (dimension + 2) + mueff));</span>
<span class="fc" id="L742">        ccov1Sep = FastMath.min(1, ccov1 * (dimension + 1.5) / 3);</span>
<span class="fc" id="L743">        ccovmuSep = FastMath.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3);</span>
<span class="fc" id="L744">        chiN = FastMath.sqrt(dimension) *</span>
<span class="fc" id="L745">            (1 - 1 / ((double) 4 * dimension) + 1 / ((double) 21 * dimension * dimension));</span>
        // intialize CMA internal values - updated each generation
<span class="fc" id="L747">        xmean = MatrixUtils.createColumnRealMatrix(guess); // objective variables</span>
<span class="fc" id="L748">        diagD = insigma.scalarMultiply(1 / sigma);</span>
<span class="fc" id="L749">        diagC = square(diagD);</span>
<span class="fc" id="L750">        pc = zeros(dimension, 1); // evolution paths for C and sigma</span>
<span class="fc" id="L751">        ps = zeros(dimension, 1); // B defines the coordinate system</span>
<span class="fc" id="L752">        normps = ps.getFrobeniusNorm();</span>

<span class="fc" id="L754">        B = eye(dimension, dimension);</span>
<span class="fc" id="L755">        D = ones(dimension, 1); // diagonal D defines the scaling</span>
<span class="fc" id="L756">        BD = times(B, repmat(diagD.transpose(), dimension, 1));</span>
<span class="fc" id="L757">        C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance</span>
<span class="fc" id="L758">        historySize = 10 + (int) (3 * 10 * dimension / (double) lambda);</span>
<span class="fc" id="L759">        fitnessHistory = new double[historySize]; // history of fitness values</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        for (int i = 0; i &lt; historySize; i++) {</span>
<span class="fc" id="L761">            fitnessHistory[i] = Double.MAX_VALUE;</span>
        }
<span class="fc" id="L763">    }</span>

    /**
     * Update of the evolution paths ps and pc.
     *
     * @param zmean Weighted row matrix of the gaussian random numbers generating
     * the current offspring.
     * @param xold xmean matrix of the previous generation.
     * @return hsig flag indicating a small correction.
     */
    private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {
<span class="fc" id="L774">        ps = ps.scalarMultiply(1 - cs).add(</span>
<span class="fc" id="L775">                B.multiply(zmean).scalarMultiply(FastMath.sqrt(cs * (2 - cs) * mueff)));</span>
<span class="fc" id="L776">        normps = ps.getFrobeniusNorm();</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">        final boolean hsig = normps /</span>
<span class="fc" id="L778">            FastMath.sqrt(1 - FastMath.pow(1 - cs, 2 * iterations)) /</span>
<span class="fc" id="L779">            chiN &lt; 1.4 + 2 / ((double) dimension + 1);</span>
<span class="fc" id="L780">        pc = pc.scalarMultiply(1 - cc);</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">        if (hsig) {</span>
<span class="fc" id="L782">            pc = pc.add(xmean.subtract(xold).scalarMultiply(FastMath.sqrt(cc * (2 - cc) * mueff) / sigma));</span>
        }
<span class="fc" id="L784">        return hsig;</span>
    }

    /**
     * Update of the covariance matrix C for diagonalOnly &gt; 0
     *
     * @param hsig Flag indicating a small correction.
     * @param bestArz Fitness-sorted matrix of the gaussian random values of the
     * current offspring.
     */
    private void updateCovarianceDiagonalOnly(boolean hsig,
                                              final RealMatrix bestArz) {
        // minor correction if hsig==false
<span class="fc bfc" id="L797" title="All 2 branches covered.">        double oldFac = hsig ? 0 : ccov1Sep * cc * (2 - cc);</span>
<span class="fc" id="L798">        oldFac += 1 - ccov1Sep - ccovmuSep;</span>
<span class="fc" id="L799">        diagC = diagC.scalarMultiply(oldFac) // regard old matrix</span>
<span class="fc" id="L800">            .add(square(pc).scalarMultiply(ccov1Sep)) // plus rank one update</span>
<span class="fc" id="L801">            .add((times(diagC, square(bestArz).multiply(weights))) // plus rank mu update</span>
<span class="fc" id="L802">                 .scalarMultiply(ccovmuSep));</span>
<span class="fc" id="L803">        diagD = sqrt(diagC); // replaces eig(C)</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">        if (diagonalOnly &gt; 1 &amp;&amp;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">            iterations &gt; diagonalOnly) {</span>
            // full covariance matrix from now on
<span class="nc" id="L807">            diagonalOnly = 0;</span>
<span class="nc" id="L808">            B = eye(dimension, dimension);</span>
<span class="nc" id="L809">            BD = diag(diagD);</span>
<span class="nc" id="L810">            C = diag(diagC);</span>
        }
<span class="fc" id="L812">    }</span>

    /**
     * Update of the covariance matrix C.
     *
     * @param hsig Flag indicating a small correction.
     * @param bestArx Fitness-sorted matrix of the argument vectors producing the
     * current offspring.
     * @param arz Unsorted matrix containing the gaussian random values of the
     * current offspring.
     * @param arindex Indices indicating the fitness-order of the current offspring.
     * @param xold xmean matrix of the previous generation.
     */
    private void updateCovariance(boolean hsig, final RealMatrix bestArx,
                                  final RealMatrix arz, final int[] arindex,
                                  final RealMatrix xold) {
<span class="fc" id="L828">        double negccov = 0;</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">        if (ccov1 + ccovmu &gt; 0) {</span>
<span class="fc" id="L830">            final RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))</span>
<span class="fc" id="L831">                .scalarMultiply(1 / sigma); // mu difference vectors</span>
<span class="fc" id="L832">            final RealMatrix roneu = pc.multiply(pc.transpose())</span>
<span class="fc" id="L833">                .scalarMultiply(ccov1); // rank one update</span>
            // minor correction if hsig==false
<span class="fc bfc" id="L835" title="All 2 branches covered.">            double oldFac = hsig ? 0 : ccov1 * cc * (2 - cc);</span>
<span class="fc" id="L836">            oldFac += 1 - ccov1 - ccovmu;</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">            if (isActiveCMA) {</span>
                // Adapt covariance matrix C active CMA
<span class="fc" id="L839">                negccov = (1 - ccovmu) * 0.25 * mueff / (FastMath.pow(dimension + 2, 1.5) + 2 * mueff);</span>
                // keep at least 0.66 in all directions, small popsize are most
                // critical
<span class="fc" id="L842">                final double negminresidualvariance = 0.66;</span>
                // where to make up for the variance loss
<span class="fc" id="L844">                final double negalphaold = 0.5;</span>
                // prepare vectors, compute negative updating matrix Cneg
<span class="fc" id="L846">                final int[] arReverseIndex = reverse(arindex);</span>
<span class="fc" id="L847">                RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));</span>
<span class="fc" id="L848">                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));</span>
<span class="fc" id="L849">                final int[] idxnorms = sortedIndices(arnorms.getRow(0));</span>
<span class="fc" id="L850">                final RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);</span>
<span class="fc" id="L851">                final int[] idxReverse = reverse(idxnorms);</span>
<span class="fc" id="L852">                final RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);</span>
<span class="fc" id="L853">                arnorms = divide(arnormsReverse, arnormsSorted);</span>
<span class="fc" id="L854">                final int[] idxInv = inverse(idxnorms);</span>
<span class="fc" id="L855">                final RealMatrix arnormsInv = selectColumns(arnorms, idxInv);</span>
                // check and set learning rate negccov
<span class="fc" id="L857">                final double negcovMax = (1 - negminresidualvariance) /</span>
<span class="fc" id="L858">                    square(arnormsInv).multiply(weights).getEntry(0, 0);</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">                if (negccov &gt; negcovMax) {</span>
<span class="fc" id="L860">                    negccov = negcovMax;</span>
                }
<span class="fc" id="L862">                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));</span>
<span class="fc" id="L863">                final RealMatrix artmp = BD.multiply(arzneg);</span>
<span class="fc" id="L864">                final RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(artmp.transpose());</span>
<span class="fc" id="L865">                oldFac += negalphaold * negccov;</span>
<span class="fc" id="L866">                C = C.scalarMultiply(oldFac)</span>
<span class="fc" id="L867">                    .add(roneu) // regard old matrix</span>
<span class="fc" id="L868">                    .add(arpos.scalarMultiply( // plus rank one update</span>
<span class="fc" id="L869">                                              ccovmu + (1 - negalphaold) * negccov) // plus rank mu update</span>
<span class="fc" id="L870">                         .multiply(times(repmat(weights, 1, dimension),</span>
<span class="fc" id="L871">                                         arpos.transpose())))</span>
<span class="fc" id="L872">                    .subtract(Cneg.scalarMultiply(negccov));</span>
<span class="fc" id="L873">            } else {</span>
                // Adapt covariance matrix C - nonactive
<span class="fc" id="L875">                C = C.scalarMultiply(oldFac) // regard old matrix</span>
<span class="fc" id="L876">                    .add(roneu) // plus rank one update</span>
<span class="fc" id="L877">                    .add(arpos.scalarMultiply(ccovmu) // plus rank mu update</span>
<span class="fc" id="L878">                         .multiply(times(repmat(weights, 1, dimension),</span>
<span class="fc" id="L879">                                         arpos.transpose())));</span>
            }
        }
<span class="fc" id="L882">        updateBD(negccov);</span>
<span class="fc" id="L883">    }</span>

    /**
     * Update B and D from C.
     *
     * @param negccov Negative covariance factor.
     */
    private void updateBD(double negccov) {
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">        if (ccov1 + ccovmu + negccov &gt; 0 &amp;&amp;</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">            (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) &lt; 1) {</span>
            // to achieve O(N^2)
<span class="fc" id="L894">            C = triu(C, 0).add(triu(C, 1).transpose());</span>
            // enforce symmetry to prevent complex numbers
<span class="fc" id="L896">            final EigenDecomposition eig = new EigenDecomposition(C);</span>
<span class="fc" id="L897">            B = eig.getV(); // eigen decomposition, B==normalized eigenvectors</span>
<span class="fc" id="L898">            D = eig.getD();</span>
<span class="fc" id="L899">            diagD = diag(D);</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">            if (min(diagD) &lt;= 0) {</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">                for (int i = 0; i &lt; dimension; i++) {</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">                    if (diagD.getEntry(i, 0) &lt; 0) {</span>
<span class="nc" id="L903">                        diagD.setEntry(i, 0, 0);</span>
                    }
                }
<span class="nc" id="L906">                final double tfac = max(diagD) / 1e14;</span>
<span class="nc" id="L907">                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));</span>
<span class="nc" id="L908">                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));</span>
            }
<span class="fc bfc" id="L910" title="All 2 branches covered.">            if (max(diagD) &gt; 1e14 * min(diagD)) {</span>
<span class="fc" id="L911">                final double tfac = max(diagD) / 1e14 - min(diagD);</span>
<span class="fc" id="L912">                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));</span>
<span class="fc" id="L913">                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));</span>
            }
<span class="fc" id="L915">            diagC = diag(C);</span>
<span class="fc" id="L916">            diagD = sqrt(diagD); // D contains standard deviations now</span>
<span class="fc" id="L917">            BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)</span>
        }
<span class="fc" id="L919">    }</span>

    /**
     * Pushes the current best fitness value in a history queue.
     *
     * @param vals History queue.
     * @param val Current best fitness value.
     */
    private static void push(double[] vals, double val) {
<span class="fc bfc" id="L928" title="All 2 branches covered.">        for (int i = vals.length-1; i &gt; 0; i--) {</span>
<span class="fc" id="L929">            vals[i] = vals[i-1];</span>
        }
<span class="fc" id="L931">        vals[0] = val;</span>
<span class="fc" id="L932">    }</span>

    /**
     * Sorts fitness values.
     *
     * @param doubles Array of values to be sorted.
     * @return a sorted array of indices pointing into doubles.
     */
    private int[] sortedIndices(final double[] doubles) {
<span class="fc" id="L941">        final DoubleIndex[] dis = new DoubleIndex[doubles.length];</span>
<span class="fc bfc" id="L942" title="All 2 branches covered.">        for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="fc" id="L943">            dis[i] = new DoubleIndex(doubles[i], i);</span>
        }
<span class="fc" id="L945">        Arrays.sort(dis);</span>
<span class="fc" id="L946">        final int[] indices = new int[doubles.length];</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">        for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="fc" id="L948">            indices[i] = dis[i].index;</span>
        }
<span class="fc" id="L950">        return indices;</span>
    }

    /**
     * Used to sort fitness values. Sorting is always in lower value first
     * order.
     */
    private static class DoubleIndex implements Comparable&lt;DoubleIndex&gt; {
        /** Value to compare. */
        private final double value;
        /** Index into sorted array. */
        private final int index;

        /**
         * @param value Value to compare.
         * @param index Index into sorted array.
         */
<span class="fc" id="L967">        DoubleIndex(double value, int index) {</span>
<span class="fc" id="L968">            this.value = value;</span>
<span class="fc" id="L969">            this.index = index;</span>
<span class="fc" id="L970">        }</span>

        /** {@inheritDoc} */
        public int compareTo(DoubleIndex o) {
<span class="fc" id="L974">            return Double.compare(value, o.value);</span>
        }

        /** {@inheritDoc} */
        @Override
        public boolean equals(Object other) {

<span class="nc bnc" id="L981" title="All 2 branches missed.">            if (this == other) {</span>
<span class="nc" id="L982">                return true;</span>
            }

<span class="nc bnc" id="L985" title="All 2 branches missed.">            if (other instanceof DoubleIndex) {</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">                return Double.compare(value, ((DoubleIndex) other).value) == 0;</span>
            }

<span class="nc" id="L989">            return false;</span>
        }

        /** {@inheritDoc} */
        @Override
        public int hashCode() {
<span class="nc" id="L995">            long bits = Double.doubleToLongBits(value);</span>
<span class="nc" id="L996">            return (int) ((1438542 ^ (bits &gt;&gt;&gt; 32) ^ bits) &amp; 0xffffffff);</span>
        }
    }

    /**
     * Normalizes fitness values to the range [0,1]. Adds a penalty to the
     * fitness value if out of range. The penalty is adjusted by calling
     * setValueRange().
     */
    private class FitnessFunction {
        /** Determines the penalty for boundary violations */
        private double valueRange;
        /**
         * Flag indicating whether the objective variables are forced into their
         * bounds if defined
         */
        private final boolean isRepairMode;

        /** Simple constructor.
         */
<span class="fc" id="L1016">        public FitnessFunction() {</span>
<span class="fc" id="L1017">            valueRange = 1;</span>
<span class="fc" id="L1018">            isRepairMode = true;</span>
<span class="fc" id="L1019">        }</span>

        /**
         * @param point Normalized objective variables.
         * @return the objective value + penalty for violated bounds.
         */
        public double value(final double[] point) {
            double value;
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">            if (isRepairMode) {</span>
<span class="fc" id="L1028">                double[] repaired = repair(point);</span>
<span class="fc" id="L1029">                value = CMAESOptimizer.this.computeObjectiveValue(repaired) +</span>
<span class="fc" id="L1030">                    penalty(point, repaired);</span>
<span class="fc" id="L1031">            } else {</span>
<span class="nc" id="L1032">                value = CMAESOptimizer.this.computeObjectiveValue(point);</span>
            }
<span class="fc bfc" id="L1034" title="All 2 branches covered.">            return isMinimize ? value : -value;</span>
        }

        /**
         * @param x Normalized objective variables.
         * @return {@code true} if in bounds.
         */
        public boolean isFeasible(final double[] x) {
<span class="nc" id="L1042">            final double[] lB = CMAESOptimizer.this.getLowerBound();</span>
<span class="nc" id="L1043">            final double[] uB = CMAESOptimizer.this.getUpperBound();</span>

<span class="nc bnc" id="L1045" title="All 2 branches missed.">            for (int i = 0; i &lt; x.length; i++) {</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                if (x[i] &lt; lB[i]) {</span>
<span class="nc" id="L1047">                    return false;</span>
                }
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                if (x[i] &gt; uB[i]) {</span>
<span class="nc" id="L1050">                    return false;</span>
                }
            }
<span class="nc" id="L1053">            return true;</span>
        }

        /**
         * @param valueRange Adjusts the penalty computation.
         */
        public void setValueRange(double valueRange) {
<span class="fc" id="L1060">            this.valueRange = valueRange;</span>
<span class="fc" id="L1061">        }</span>

        /**
         * @param x Normalized objective variables.
         * @return the repaired (i.e. all in bounds) objective variables.
         */
        private double[] repair(final double[] x) {
<span class="fc" id="L1068">            final double[] lB = CMAESOptimizer.this.getLowerBound();</span>
<span class="fc" id="L1069">            final double[] uB = CMAESOptimizer.this.getUpperBound();</span>

<span class="fc" id="L1071">            final double[] repaired = new double[x.length];</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">                if (x[i] &lt; lB[i]) {</span>
<span class="fc" id="L1074">                    repaired[i] = lB[i];</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">                } else if (x[i] &gt; uB[i]) {</span>
<span class="fc" id="L1076">                    repaired[i] = uB[i];</span>
<span class="fc" id="L1077">                } else {</span>
<span class="fc" id="L1078">                    repaired[i] = x[i];</span>
                }
            }
<span class="fc" id="L1081">            return repaired;</span>
        }

        /**
         * @param x Normalized objective variables.
         * @param repaired Repaired objective variables.
         * @return Penalty value according to the violation of the bounds.
         */
        private double penalty(final double[] x, final double[] repaired) {
<span class="fc" id="L1090">            double penalty = 0;</span>
<span class="fc bfc" id="L1091" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc" id="L1092">                double diff = FastMath.abs(x[i] - repaired[i]);</span>
<span class="fc" id="L1093">                penalty += diff * valueRange;</span>
            }
<span class="fc bfc" id="L1095" title="All 2 branches covered.">            return isMinimize ? penalty : -penalty;</span>
        }
    }

    // -----Matrix utility functions similar to the Matlab build in functions------

    /**
     * @param m Input matrix
     * @return Matrix representing the element-wise logarithm of m.
     */
    private static RealMatrix log(final RealMatrix m) {
<span class="fc" id="L1106">        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">        for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">            for (int c = 0; c &lt; m.getColumnDimension(); c++) {</span>
<span class="fc" id="L1109">                d[r][c] = FastMath.log(m.getEntry(r, c));</span>
            }
        }
<span class="fc" id="L1112">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param m Input matrix.
     * @return Matrix representing the element-wise square root of m.
     */
    private static RealMatrix sqrt(final RealMatrix m) {
<span class="fc" id="L1120">        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];</span>
<span class="fc bfc" id="L1121" title="All 2 branches covered.">        for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">            for (int c = 0; c &lt; m.getColumnDimension(); c++) {</span>
<span class="fc" id="L1123">                d[r][c] = FastMath.sqrt(m.getEntry(r, c));</span>
            }
        }
<span class="fc" id="L1126">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param m Input matrix.
     * @return Matrix representing the element-wise square of m.
     */
    private static RealMatrix square(final RealMatrix m) {
<span class="fc" id="L1134">        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">        for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc bfc" id="L1136" title="All 2 branches covered.">            for (int c = 0; c &lt; m.getColumnDimension(); c++) {</span>
<span class="fc" id="L1137">                double e = m.getEntry(r, c);</span>
<span class="fc" id="L1138">                d[r][c] = e * e;</span>
            }
        }
<span class="fc" id="L1141">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param m Input matrix 1.
     * @param n Input matrix 2.
     * @return the matrix where the elements of m and n are element-wise multiplied.
     */
    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {
<span class="fc" id="L1150">        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">        for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">            for (int c = 0; c &lt; m.getColumnDimension(); c++) {</span>
<span class="fc" id="L1153">                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);</span>
            }
        }
<span class="fc" id="L1156">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param m Input matrix 1.
     * @param n Input matrix 2.
     * @return Matrix where the elements of m and n are element-wise divided.
     */
    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {
<span class="fc" id="L1165">        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">        for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc bfc" id="L1167" title="All 2 branches covered.">            for (int c = 0; c &lt; m.getColumnDimension(); c++) {</span>
<span class="fc" id="L1168">                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);</span>
            }
        }
<span class="fc" id="L1171">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param m Input matrix.
     * @param cols Columns to select.
     * @return Matrix representing the selected columns.
     */
    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {
<span class="fc" id="L1180">        final double[][] d = new double[m.getRowDimension()][cols.length];</span>
<span class="fc bfc" id="L1181" title="All 2 branches covered.">        for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">            for (int c = 0; c &lt; cols.length; c++) {</span>
<span class="fc" id="L1183">                d[r][c] = m.getEntry(r, cols[c]);</span>
            }
        }
<span class="fc" id="L1186">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param m Input matrix.
     * @param k Diagonal position.
     * @return Upper triangular part of matrix.
     */
    private static RealMatrix triu(final RealMatrix m, int k) {
<span class="fc" id="L1195">        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];</span>
<span class="fc bfc" id="L1196" title="All 2 branches covered.">        for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc bfc" id="L1197" title="All 2 branches covered.">            for (int c = 0; c &lt; m.getColumnDimension(); c++) {</span>
<span class="fc bfc" id="L1198" title="All 2 branches covered.">                d[r][c] = r &lt;= c - k ? m.getEntry(r, c) : 0;</span>
            }
        }
<span class="fc" id="L1201">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param m Input matrix.
     * @return Row matrix representing the sums of the rows.
     */
    private static RealMatrix sumRows(final RealMatrix m) {
<span class="fc" id="L1209">        final double[][] d = new double[1][m.getColumnDimension()];</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        for (int c = 0; c &lt; m.getColumnDimension(); c++) {</span>
<span class="fc" id="L1211">            double sum = 0;</span>
<span class="fc bfc" id="L1212" title="All 2 branches covered.">            for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc" id="L1213">                sum += m.getEntry(r, c);</span>
            }
<span class="fc" id="L1215">            d[0][c] = sum;</span>
        }
<span class="fc" id="L1217">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param m Input matrix.
     * @return the diagonal n-by-n matrix if m is a column matrix or the column
     * matrix representing the diagonal if m is a n-by-n matrix.
     */
    private static RealMatrix diag(final RealMatrix m) {
<span class="fc bfc" id="L1226" title="All 2 branches covered.">        if (m.getColumnDimension() == 1) {</span>
<span class="fc" id="L1227">            final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">            for (int i = 0; i &lt; m.getRowDimension(); i++) {</span>
<span class="fc" id="L1229">                d[i][i] = m.getEntry(i, 0);</span>
            }
<span class="fc" id="L1231">            return new Array2DRowRealMatrix(d, false);</span>
        } else {
<span class="fc" id="L1233">            final double[][] d = new double[m.getRowDimension()][1];</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">            for (int i = 0; i &lt; m.getColumnDimension(); i++) {</span>
<span class="fc" id="L1235">                d[i][0] = m.getEntry(i, i);</span>
            }
<span class="fc" id="L1237">            return new Array2DRowRealMatrix(d, false);</span>
        }
    }

    /**
     * Copies a column from m1 to m2.
     *
     * @param m1 Source matrix.
     * @param col1 Source column.
     * @param m2 Target matrix.
     * @param col2 Target column.
     */
    private static void copyColumn(final RealMatrix m1, int col1,
                                   RealMatrix m2, int col2) {
<span class="fc bfc" id="L1251" title="All 2 branches covered.">        for (int i = 0; i &lt; m1.getRowDimension(); i++) {</span>
<span class="fc" id="L1252">            m2.setEntry(i, col2, m1.getEntry(i, col1));</span>
        }
<span class="fc" id="L1254">    }</span>

    /**
     * @param n Number of rows.
     * @param m Number of columns.
     * @return n-by-m matrix filled with 1.
     */
    private static RealMatrix ones(int n, int m) {
<span class="fc" id="L1262">        final double[][] d = new double[n][m];</span>
<span class="fc bfc" id="L1263" title="All 2 branches covered.">        for (int r = 0; r &lt; n; r++) {</span>
<span class="fc" id="L1264">            Arrays.fill(d[r], 1);</span>
        }
<span class="fc" id="L1266">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param n Number of rows.
     * @param m Number of columns.
     * @return n-by-m matrix of 0 values out of diagonal, and 1 values on
     * the diagonal.
     */
    private static RealMatrix eye(int n, int m) {
<span class="fc" id="L1276">        final double[][] d = new double[n][m];</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">        for (int r = 0; r &lt; n; r++) {</span>
<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">            if (r &lt; m) {</span>
<span class="fc" id="L1279">                d[r][r] = 1;</span>
            }
        }
<span class="fc" id="L1282">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param n Number of rows.
     * @param m Number of columns.
     * @return n-by-m matrix of zero values.
     */
    private static RealMatrix zeros(int n, int m) {
<span class="fc" id="L1291">        return new Array2DRowRealMatrix(n, m);</span>
    }

    /**
     * @param mat Input matrix.
     * @param n Number of row replicates.
     * @param m Number of column replicates.
     * @return a matrix which replicates the input matrix in both directions.
     */
    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {
<span class="fc" id="L1301">        final int rd = mat.getRowDimension();</span>
<span class="fc" id="L1302">        final int cd = mat.getColumnDimension();</span>
<span class="fc" id="L1303">        final double[][] d = new double[n * rd][m * cd];</span>
<span class="fc bfc" id="L1304" title="All 2 branches covered.">        for (int r = 0; r &lt; n * rd; r++) {</span>
<span class="fc bfc" id="L1305" title="All 2 branches covered.">            for (int c = 0; c &lt; m * cd; c++) {</span>
<span class="fc" id="L1306">                d[r][c] = mat.getEntry(r % rd, c % cd);</span>
            }
        }
<span class="fc" id="L1309">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param start Start value.
     * @param end End value.
     * @param step Step size.
     * @return a sequence as column matrix.
     */
    private static RealMatrix sequence(double start, double end, double step) {
<span class="fc" id="L1319">        final int size = (int) ((end - start) / step + 1);</span>
<span class="fc" id="L1320">        final double[][] d = new double[size][1];</span>
<span class="fc" id="L1321">        double value = start;</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        for (int r = 0; r &lt; size; r++) {</span>
<span class="fc" id="L1323">            d[r][0] = value;</span>
<span class="fc" id="L1324">            value += step;</span>
        }
<span class="fc" id="L1326">        return new Array2DRowRealMatrix(d, false);</span>
    }

    /**
     * @param m Input matrix.
     * @return the maximum of the matrix element values.
     */
    private static double max(final RealMatrix m) {
<span class="fc" id="L1334">        double max = -Double.MAX_VALUE;</span>
<span class="fc bfc" id="L1335" title="All 2 branches covered.">        for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">            for (int c = 0; c &lt; m.getColumnDimension(); c++) {</span>
<span class="fc" id="L1337">                double e = m.getEntry(r, c);</span>
<span class="fc bfc" id="L1338" title="All 2 branches covered.">                if (max &lt; e) {</span>
<span class="fc" id="L1339">                    max = e;</span>
                }
            }
        }
<span class="fc" id="L1343">        return max;</span>
    }

    /**
     * @param m Input matrix.
     * @return the minimum of the matrix element values.
     */
    private static double min(final RealMatrix m) {
<span class="fc" id="L1351">        double min = Double.MAX_VALUE;</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">        for (int r = 0; r &lt; m.getRowDimension(); r++) {</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">            for (int c = 0; c &lt; m.getColumnDimension(); c++) {</span>
<span class="fc" id="L1354">                double e = m.getEntry(r, c);</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">                if (min &gt; e) {</span>
<span class="fc" id="L1356">                    min = e;</span>
                }
            }
        }
<span class="fc" id="L1360">        return min;</span>
    }

    /**
     * @param m Input array.
     * @return the maximum of the array values.
     */
    private static double max(final double[] m) {
<span class="fc" id="L1368">        double max = -Double.MAX_VALUE;</span>
<span class="fc bfc" id="L1369" title="All 2 branches covered.">        for (int r = 0; r &lt; m.length; r++) {</span>
<span class="fc bfc" id="L1370" title="All 2 branches covered.">            if (max &lt; m[r]) {</span>
<span class="fc" id="L1371">                max = m[r];</span>
            }
        }
<span class="fc" id="L1374">        return max;</span>
    }

    /**
     * @param m Input array.
     * @return the minimum of the array values.
     */
    private static double min(final double[] m) {
<span class="fc" id="L1382">        double min = Double.MAX_VALUE;</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">        for (int r = 0; r &lt; m.length; r++) {</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">            if (min &gt; m[r]) {</span>
<span class="fc" id="L1385">                min = m[r];</span>
            }
        }
<span class="fc" id="L1388">        return min;</span>
    }

    /**
     * @param indices Input index array.
     * @return the inverse of the mapping defined by indices.
     */
    private static int[] inverse(final int[] indices) {
<span class="fc" id="L1396">        final int[] inverse = new int[indices.length];</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">        for (int i = 0; i &lt; indices.length; i++) {</span>
<span class="fc" id="L1398">            inverse[indices[i]] = i;</span>
        }
<span class="fc" id="L1400">        return inverse;</span>
    }

    /**
     * @param indices Input index array.
     * @return the indices in inverse order (last is first).
     */
    private static int[] reverse(final int[] indices) {
<span class="fc" id="L1408">        final int[] reverse = new int[indices.length];</span>
<span class="fc bfc" id="L1409" title="All 2 branches covered.">        for (int i = 0; i &lt; indices.length; i++) {</span>
<span class="fc" id="L1410">            reverse[i] = indices[indices.length - i - 1];</span>
        }
<span class="fc" id="L1412">        return reverse;</span>
    }

    /**
     * @param size Length of random array.
     * @return an array of Gaussian random numbers.
     */
    private double[] randn(int size) {
<span class="nc" id="L1420">        final double[] randn = new double[size];</span>
<span class="nc bnc" id="L1421" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1422">            randn[i] = random.nextGaussian();</span>
        }
<span class="nc" id="L1424">        return randn;</span>
    }

    /**
     * @param size Number of rows.
     * @param popSize Population size.
     * @return a 2-dimensional matrix of Gaussian random numbers.
     */
    private RealMatrix randn1(int size, int popSize) {
<span class="fc" id="L1433">        final double[][] d = new double[size][popSize];</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        for (int r = 0; r &lt; size; r++) {</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">            for (int c = 0; c &lt; popSize; c++) {</span>
<span class="fc" id="L1436">                d[r][c] = random.nextGaussian();</span>
            }
        }
<span class="fc" id="L1439">        return new Array2DRowRealMatrix(d, false);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>