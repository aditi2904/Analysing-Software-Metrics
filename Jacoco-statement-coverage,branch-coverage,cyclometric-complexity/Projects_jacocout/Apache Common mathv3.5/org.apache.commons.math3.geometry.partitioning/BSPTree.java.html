<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BSPTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.geometry.partitioning</a> &gt; <span class="el_source">BSPTree.java</span></div><h1>BSPTree.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math3.geometry.partitioning;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.math3.exception.MathIllegalStateException;
import org.apache.commons.math3.exception.MathInternalError;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.geometry.Point;
import org.apache.commons.math3.geometry.Space;
import org.apache.commons.math3.geometry.Vector;
import org.apache.commons.math3.util.FastMath;

/** This class represent a Binary Space Partition tree.

 * &lt;p&gt;BSP trees are an efficient way to represent space partitions and
 * to associate attributes with each cell. Each node in a BSP tree
 * represents a convex region which is partitioned in two convex
 * sub-regions at each side of a cut hyperplane. The root tree
 * contains the complete space.&lt;/p&gt;

 * &lt;p&gt;The main use of such partitions is to use a boolean attribute to
 * define an inside/outside property, hence representing arbitrary
 * polytopes (line segments in 1D, polygons in 2D and polyhedrons in
 * 3D) and to operate on them.&lt;/p&gt;

 * &lt;p&gt;Another example would be to represent Voronoi tesselations, the
 * attribute of each cell holding the defining point of the cell.&lt;/p&gt;

 * &lt;p&gt;The application-defined attributes are shared among copied
 * instances and propagated to split parts. These attributes are not
 * used by the BSP-tree algorithms themselves, so the application can
 * use them for any purpose. Since the tree visiting method holds
 * internal and leaf nodes differently, it is possible to use
 * different classes for internal nodes attributes and leaf nodes
 * attributes. This should be used with care, though, because if the
 * tree is modified in any way after attributes have been set, some
 * internal nodes may become leaf nodes and some leaf nodes may become
 * internal nodes.&lt;/p&gt;

 * &lt;p&gt;One of the main sources for the development of this package was
 * Bruce Naylor, John Amanatides and William Thibault paper &lt;a
 * href=&quot;http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf&quot;&gt;Merging
 * BSP Trees Yields Polyhedral Set Operations&lt;/a&gt; Proc. Siggraph '90,
 * Computer Graphics 24(4), August 1990, pp 115-124, published by the
 * Association for Computing Machinery (ACM).&lt;/p&gt;

 * @param &lt;S&gt; Type of the space.

 * @since 3.0
 */
public class BSPTree&lt;S extends Space&gt; {

    /** Cut sub-hyperplane. */
    private SubHyperplane&lt;S&gt; cut;

    /** Tree at the plus side of the cut hyperplane. */
    private BSPTree&lt;S&gt; plus;

    /** Tree at the minus side of the cut hyperplane. */
    private BSPTree&lt;S&gt; minus;

    /** Parent tree. */
    private BSPTree&lt;S&gt; parent;

    /** Application-defined attribute. */
    private Object attribute;

    /** Build a tree having only one root cell representing the whole space.
     */
<span class="fc" id="L87">    public BSPTree() {</span>
<span class="fc" id="L88">        cut       = null;</span>
<span class="fc" id="L89">        plus      = null;</span>
<span class="fc" id="L90">        minus     = null;</span>
<span class="fc" id="L91">        parent    = null;</span>
<span class="fc" id="L92">        attribute = null;</span>
<span class="fc" id="L93">    }</span>

    /** Build a tree having only one root cell representing the whole space.
     * @param attribute attribute of the tree (may be null)
     */
<span class="fc" id="L98">    public BSPTree(final Object attribute) {</span>
<span class="fc" id="L99">        cut    = null;</span>
<span class="fc" id="L100">        plus   = null;</span>
<span class="fc" id="L101">        minus  = null;</span>
<span class="fc" id="L102">        parent = null;</span>
<span class="fc" id="L103">        this.attribute = attribute;</span>
<span class="fc" id="L104">    }</span>

    /** Build a BSPTree from its underlying elements.
     * &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; perform any verification on
     * consistency of its arguments, it should therefore be used only
     * when then caller knows what it is doing.&lt;/p&gt;
     * &lt;p&gt;This method is mainly useful to build trees
     * bottom-up. Building trees top-down is realized with the help of
     * method {@link #insertCut insertCut}.&lt;/p&gt;
     * @param cut cut sub-hyperplane for the tree
     * @param plus plus side sub-tree
     * @param minus minus side sub-tree
     * @param attribute attribute associated with the node (may be null)
     * @see #insertCut
     */
<span class="fc" id="L119">    public BSPTree(final SubHyperplane&lt;S&gt; cut, final BSPTree&lt;S&gt; plus, final BSPTree&lt;S&gt; minus,</span>
                   final Object attribute) {
<span class="fc" id="L121">        this.cut       = cut;</span>
<span class="fc" id="L122">        this.plus      = plus;</span>
<span class="fc" id="L123">        this.minus     = minus;</span>
<span class="fc" id="L124">        this.parent    = null;</span>
<span class="fc" id="L125">        this.attribute = attribute;</span>
<span class="fc" id="L126">        plus.parent    = this;</span>
<span class="fc" id="L127">        minus.parent   = this;</span>
<span class="fc" id="L128">    }</span>

    /** Insert a cut sub-hyperplane in a node.
     * &lt;p&gt;The sub-tree starting at this node will be completely
     * overwritten. The new cut sub-hyperplane will be built from the
     * intersection of the provided hyperplane with the cell. If the
     * hyperplane does intersect the cell, the cell will have two
     * children cells with {@code null} attributes on each side of
     * the inserted cut sub-hyperplane. If the hyperplane does not
     * intersect the cell then &lt;em&gt;no&lt;/em&gt; cut hyperplane will be
     * inserted and the cell will be changed to a leaf cell. The
     * attribute of the node is never changed.&lt;/p&gt;
     * &lt;p&gt;This method is mainly useful when called on leaf nodes
     * (i.e. nodes for which {@link #getCut getCut} returns
     * {@code null}), in this case it provides a way to build a
     * tree top-down (whereas the {@link #BSPTree(SubHyperplane,
     * BSPTree, BSPTree, Object) 4 arguments constructor} is devoted to
     * build trees bottom-up).&lt;/p&gt;
     * @param hyperplane hyperplane to insert, it will be chopped in
     * order to fit in the cell defined by the parent nodes of the
     * instance
     * @return true if a cut sub-hyperplane has been inserted (i.e. if
     * the cell now has two leaf child nodes)
     * @see #BSPTree(SubHyperplane, BSPTree, BSPTree, Object)
     */
    public boolean insertCut(final Hyperplane&lt;S&gt; hyperplane) {

<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (cut != null) {</span>
<span class="nc" id="L156">            plus.parent  = null;</span>
<span class="nc" id="L157">            minus.parent = null;</span>
        }

<span class="fc" id="L160">        final SubHyperplane&lt;S&gt; chopped = fitToCell(hyperplane.wholeHyperplane());</span>
<span class="pc bpc" id="L161" title="1 of 4 branches missed.">        if (chopped == null || chopped.isEmpty()) {</span>
<span class="fc" id="L162">            cut          = null;</span>
<span class="fc" id="L163">            plus         = null;</span>
<span class="fc" id="L164">            minus        = null;</span>
<span class="fc" id="L165">            return false;</span>
        }

<span class="fc" id="L168">        cut          = chopped;</span>
<span class="fc" id="L169">        plus         = new BSPTree&lt;S&gt;();</span>
<span class="fc" id="L170">        plus.parent  = this;</span>
<span class="fc" id="L171">        minus        = new BSPTree&lt;S&gt;();</span>
<span class="fc" id="L172">        minus.parent = this;</span>
<span class="fc" id="L173">        return true;</span>

    }

    /** Copy the instance.
     * &lt;p&gt;The instance created is completely independent of the original
     * one. A deep copy is used, none of the underlying objects are
     * shared (except for the nodes attributes and immutable
     * objects).&lt;/p&gt;
     * @return a new tree, copy of the instance
     */
    public BSPTree&lt;S&gt; copySelf() {

<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (cut == null) {</span>
<span class="fc" id="L187">            return new BSPTree&lt;S&gt;(attribute);</span>
        }

<span class="fc" id="L190">        return new BSPTree&lt;S&gt;(cut.copySelf(), plus.copySelf(), minus.copySelf(),</span>
<span class="fc" id="L191">                           attribute);</span>

    }

    /** Get the cut sub-hyperplane.
     * @return cut sub-hyperplane, null if this is a leaf tree
     */
    public SubHyperplane&lt;S&gt; getCut() {
<span class="fc" id="L199">        return cut;</span>
    }

    /** Get the tree on the plus side of the cut hyperplane.
     * @return tree on the plus side of the cut hyperplane, null if this
     * is a leaf tree
     */
    public BSPTree&lt;S&gt; getPlus() {
<span class="fc" id="L207">        return plus;</span>
    }

    /** Get the tree on the minus side of the cut hyperplane.
     * @return tree on the minus side of the cut hyperplane, null if this
     * is a leaf tree
     */
    public BSPTree&lt;S&gt; getMinus() {
<span class="fc" id="L215">        return minus;</span>
    }

    /** Get the parent node.
     * @return parent node, null if the node has no parents
     */
    public BSPTree&lt;S&gt; getParent() {
<span class="fc" id="L222">        return parent;</span>
    }

    /** Associate an attribute with the instance.
     * @param attribute attribute to associate with the node
     * @see #getAttribute
     */
    public void setAttribute(final Object attribute) {
<span class="fc" id="L230">        this.attribute = attribute;</span>
<span class="fc" id="L231">    }</span>

    /** Get the attribute associated with the instance.
     * @return attribute associated with the node or null if no
     * attribute has been explicitly set using the {@link #setAttribute
     * setAttribute} method
     * @see #setAttribute
     */
    public Object getAttribute() {
<span class="fc" id="L240">        return attribute;</span>
    }

    /** Visit the BSP tree nodes.
     * @param visitor object visiting the tree nodes
     */
    public void visit(final BSPTreeVisitor&lt;S&gt; visitor) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (cut == null) {</span>
<span class="fc" id="L248">            visitor.visitLeafNode(this);</span>
<span class="fc" id="L249">        } else {</span>
<span class="pc bpc" id="L250" title="2 of 7 branches missed.">            switch (visitor.visitOrder(this)) {</span>
            case PLUS_MINUS_SUB:
<span class="fc" id="L252">                plus.visit(visitor);</span>
<span class="fc" id="L253">                minus.visit(visitor);</span>
<span class="fc" id="L254">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L255">                break;</span>
            case PLUS_SUB_MINUS:
<span class="fc" id="L257">                plus.visit(visitor);</span>
<span class="fc" id="L258">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L259">                minus.visit(visitor);</span>
<span class="fc" id="L260">                break;</span>
            case MINUS_PLUS_SUB:
<span class="nc" id="L262">                minus.visit(visitor);</span>
<span class="nc" id="L263">                plus.visit(visitor);</span>
<span class="nc" id="L264">                visitor.visitInternalNode(this);</span>
<span class="nc" id="L265">                break;</span>
            case MINUS_SUB_PLUS:
<span class="fc" id="L267">                minus.visit(visitor);</span>
<span class="fc" id="L268">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L269">                plus.visit(visitor);</span>
<span class="fc" id="L270">                break;</span>
            case SUB_PLUS_MINUS:
<span class="fc" id="L272">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L273">                plus.visit(visitor);</span>
<span class="fc" id="L274">                minus.visit(visitor);</span>
<span class="fc" id="L275">                break;</span>
            case SUB_MINUS_PLUS:
<span class="fc" id="L277">                visitor.visitInternalNode(this);</span>
<span class="fc" id="L278">                minus.visit(visitor);</span>
<span class="fc" id="L279">                plus.visit(visitor);</span>
<span class="fc" id="L280">                break;</span>
            default:
<span class="nc" id="L282">                throw new MathInternalError();</span>
            }

        }
<span class="fc" id="L286">    }</span>

    /** Fit a sub-hyperplane inside the cell defined by the instance.
     * &lt;p&gt;Fitting is done by chopping off the parts of the
     * sub-hyperplane that lie outside of the cell using the
     * cut-hyperplanes of the parent nodes of the instance.&lt;/p&gt;
     * @param sub sub-hyperplane to fit
     * @return a new sub-hyperplane, guaranteed to have no part outside
     * of the instance cell
     */
    private SubHyperplane&lt;S&gt; fitToCell(final SubHyperplane&lt;S&gt; sub) {
<span class="fc" id="L297">        SubHyperplane&lt;S&gt; s = sub;</span>
<span class="fc bfc" id="L298" title="All 4 branches covered.">        for (BSPTree&lt;S&gt; tree = this; tree.parent != null &amp;&amp; s != null; tree = tree.parent) {</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (tree == tree.parent.plus) {</span>
<span class="fc" id="L300">                s = s.split(tree.parent.cut.getHyperplane()).getPlus();</span>
<span class="fc" id="L301">            } else {</span>
<span class="fc" id="L302">                s = s.split(tree.parent.cut.getHyperplane()).getMinus();</span>
            }
        }
<span class="fc" id="L305">        return s;</span>
    }

    /** Get the cell to which a point belongs.
     * &lt;p&gt;If the returned cell is a leaf node the points belongs to the
     * interior of the node, if the cell is an internal node the points
     * belongs to the node cut sub-hyperplane.&lt;/p&gt;
     * @param point point to check
     * @return the tree cell to which the point belongs
     * @deprecated as of 3.3, replaced with {@link #getCell(Point, double)}
     */
    @Deprecated
    public BSPTree&lt;S&gt; getCell(final Vector&lt;S&gt; point) {
<span class="nc" id="L318">        return getCell((Point&lt;S&gt;) point, 1.0e-10);</span>
    }

    /** Get the cell to which a point belongs.
     * &lt;p&gt;If the returned cell is a leaf node the points belongs to the
     * interior of the node, if the cell is an internal node the points
     * belongs to the node cut sub-hyperplane.&lt;/p&gt;
     * @param point point to check
     * @param tolerance tolerance below which points close to a cut hyperplane
     * are considered to belong to the hyperplane itself
     * @return the tree cell to which the point belongs
     */
    public BSPTree&lt;S&gt; getCell(final Point&lt;S&gt; point, final double tolerance) {

<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (cut == null) {</span>
<span class="fc" id="L333">            return this;</span>
        }

        // position of the point with respect to the cut hyperplane
<span class="fc" id="L337">        final double offset = cut.getHyperplane().getOffset(point);</span>

<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (FastMath.abs(offset) &lt; tolerance) {</span>
<span class="fc" id="L340">            return this;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">        } else if (offset &lt;= 0) {</span>
            // point is on the minus side of the cut hyperplane
<span class="fc" id="L343">            return minus.getCell(point, tolerance);</span>
        } else {
            // point is on the plus side of the cut hyperplane
<span class="fc" id="L346">            return plus.getCell(point, tolerance);</span>
        }

    }

    /** Get the cells whose cut sub-hyperplanes are close to the point.
     * @param point point to check
     * @param maxOffset offset below which a cut sub-hyperplane is considered
     * close to the point (in absolute value)
     * @return close cells (may be empty if all cut sub-hyperplanes are farther
     * than maxOffset from the point)
     */
    public List&lt;BSPTree&lt;S&gt;&gt; getCloseCuts(final Point&lt;S&gt; point, final double maxOffset) {
<span class="fc" id="L359">        final List&lt;BSPTree&lt;S&gt;&gt; close = new ArrayList&lt;BSPTree&lt;S&gt;&gt;();</span>
<span class="fc" id="L360">        recurseCloseCuts(point, maxOffset, close);</span>
<span class="fc" id="L361">        return close;</span>
    }

    /** Get the cells whose cut sub-hyperplanes are close to the point.
     * @param point point to check
     * @param maxOffset offset below which a cut sub-hyperplane is considered
     * close to the point (in absolute value)
     * @param close list to fill
     */
    private void recurseCloseCuts(final Point&lt;S&gt; point, final double maxOffset,
                                  final List&lt;BSPTree&lt;S&gt;&gt; close) {
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (cut != null) {</span>

            // position of the point with respect to the cut hyperplane
<span class="fc" id="L375">            final double offset = cut.getHyperplane().getOffset(point);</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (offset &lt; -maxOffset) {</span>
                // point is on the minus side of the cut hyperplane
<span class="fc" id="L379">                minus.recurseCloseCuts(point, maxOffset, close);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            } else if (offset &gt; maxOffset) {</span>
                // point is on the plus side of the cut hyperplane
<span class="fc" id="L382">                plus.recurseCloseCuts(point, maxOffset, close);</span>
<span class="fc" id="L383">            } else {</span>
                // point is close to the cut hyperplane
<span class="fc" id="L385">                close.add(this);</span>
<span class="fc" id="L386">                minus.recurseCloseCuts(point, maxOffset, close);</span>
<span class="fc" id="L387">                plus.recurseCloseCuts(point, maxOffset, close);</span>
            }

        }
<span class="fc" id="L391">    }</span>

    /** Perform condensation on a tree.
     * &lt;p&gt;The condensation operation is not recursive, it must be called
     * explicitly from leaves to root.&lt;/p&gt;
     */
    private void condense() {
<span class="pc bpc" id="L398" title="1 of 6 branches missed.">        if ((cut != null) &amp;&amp; (plus.cut == null) &amp;&amp; (minus.cut == null) &amp;&amp;</span>
<span class="pc bpc" id="L399" title="3 of 4 branches missed.">            (((plus.attribute == null) &amp;&amp; (minus.attribute == null)) ||</span>
<span class="pc bpc" id="L400" title="1 of 4 branches missed.">             ((plus.attribute != null) &amp;&amp; plus.attribute.equals(minus.attribute)))) {</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            attribute = (plus.attribute == null) ? minus.attribute : plus.attribute;</span>
<span class="fc" id="L402">            cut       = null;</span>
<span class="fc" id="L403">            plus      = null;</span>
<span class="fc" id="L404">            minus     = null;</span>
        }
<span class="fc" id="L406">    }</span>

    /** Merge a BSP tree with the instance.
     * &lt;p&gt;All trees are modified (parts of them are reused in the new
     * tree), it is the responsibility of the caller to ensure a copy
     * has been done before if any of the former tree should be
     * preserved, &lt;em&gt;no&lt;/em&gt; such copy is done here!&lt;/p&gt;
     * &lt;p&gt;The algorithm used here is directly derived from the one
     * described in the Naylor, Amanatides and Thibault paper (section
     * III, Binary Partitioning of a BSP Tree).&lt;/p&gt;
     * @param tree other tree to merge with the instance (will be
     * &lt;em&gt;unusable&lt;/em&gt; after the operation, as well as the
     * instance itself)
     * @param leafMerger object implementing the final merging phase
     * (this is where the semantic of the operation occurs, generally
     * depending on the attribute of the leaf node)
     * @return a new tree, result of &lt;code&gt;instance &amp;lt;op&amp;gt;
     * tree&lt;/code&gt;, this value can be ignored if parentTree is not null
     * since all connections have already been established
     */
    public BSPTree&lt;S&gt; merge(final BSPTree&lt;S&gt; tree, final LeafMerger&lt;S&gt; leafMerger) {
<span class="fc" id="L427">        return merge(tree, leafMerger, null, false);</span>
    }

    /** Merge a BSP tree with the instance.
     * @param tree other tree to merge with the instance (will be
     * &lt;em&gt;unusable&lt;/em&gt; after the operation, as well as the
     * instance itself)
     * @param leafMerger object implementing the final merging phase
     * (this is where the semantic of the operation occurs, generally
     * depending on the attribute of the leaf node)
     * @param parentTree parent tree to connect to (may be null)
     * @param isPlusChild if true and if parentTree is not null, the
     * resulting tree should be the plus child of its parent, ignored if
     * parentTree is null
     * @return a new tree, result of &lt;code&gt;instance &amp;lt;op&amp;gt;
     * tree&lt;/code&gt;, this value can be ignored if parentTree is not null
     * since all connections have already been established
     */
    private BSPTree&lt;S&gt; merge(final BSPTree&lt;S&gt; tree, final LeafMerger&lt;S&gt; leafMerger,
                             final BSPTree&lt;S&gt; parentTree, final boolean isPlusChild) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (cut == null) {</span>
            // cell/tree operation
<span class="fc" id="L449">            return leafMerger.merge(this, tree, parentTree, isPlusChild, true);</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">        } else if (tree.cut == null) {</span>
            // tree/cell operation
<span class="fc" id="L452">            return leafMerger.merge(tree, this, parentTree, isPlusChild, false);</span>
        } else {
            // tree/tree operation
<span class="fc" id="L455">            final BSPTree&lt;S&gt; merged = tree.split(cut);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            if (parentTree != null) {</span>
<span class="fc" id="L457">                merged.parent = parentTree;</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">                if (isPlusChild) {</span>
<span class="fc" id="L459">                    parentTree.plus = merged;</span>
<span class="fc" id="L460">                } else {</span>
<span class="fc" id="L461">                    parentTree.minus = merged;</span>
                }
            }

            // merging phase
<span class="fc" id="L466">            plus.merge(merged.plus, leafMerger, merged, true);</span>
<span class="fc" id="L467">            minus.merge(merged.minus, leafMerger, merged, false);</span>
<span class="fc" id="L468">            merged.condense();</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            if (merged.cut != null) {</span>
<span class="fc" id="L470">                merged.cut = merged.fitToCell(merged.cut.getHyperplane().wholeHyperplane());</span>
            }

<span class="fc" id="L473">            return merged;</span>

        }
    }

    /** This interface gather the merging operations between a BSP tree
     * leaf and another BSP tree.
     * &lt;p&gt;As explained in Bruce Naylor, John Amanatides and William
     * Thibault paper &lt;a
     * href=&quot;http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf&quot;&gt;Merging
     * BSP Trees Yields Polyhedral Set Operations&lt;/a&gt;,
     * the operations on {@link BSPTree BSP trees} can be expressed as a
     * generic recursive merging operation where only the final part,
     * when one of the operand is a leaf, is specific to the real
     * operation semantics. For example, a tree representing a region
     * using a boolean attribute to identify inside cells and outside
     * cells would use four different objects to implement the final
     * merging phase of the four set operations union, intersection,
     * difference and symmetric difference (exclusive or).&lt;/p&gt;
     * @param &lt;S&gt; Type of the space.
     */
    public interface LeafMerger&lt;S extends Space&gt; {

        /** Merge a leaf node and a tree node.
         * &lt;p&gt;This method is called at the end of a recursive merging
         * resulting from a {@code tree1.merge(tree2, leafMerger)}
         * call, when one of the sub-trees involved is a leaf (i.e. when
         * its cut-hyperplane is null). This is the only place where the
         * precise semantics of the operation are required. For all upper
         * level nodes in the tree, the merging operation is only a
         * generic partitioning algorithm.&lt;/p&gt;
         * &lt;p&gt;Since the final operation may be non-commutative, it is
         * important to know if the leaf node comes from the instance tree
         * ({@code tree1}) or the argument tree
         * ({@code tree2}). The third argument of the method is
         * devoted to this. It can be ignored for commutative
         * operations.&lt;/p&gt;
         * &lt;p&gt;The {@link BSPTree#insertInTree BSPTree.insertInTree} method
         * may be useful to implement this method.&lt;/p&gt;
         * @param leaf leaf node (its cut hyperplane is guaranteed to be
         * null)
         * @param tree tree node (its cut hyperplane may be null or not)
         * @param parentTree parent tree to connect to (may be null)
         * @param isPlusChild if true and if parentTree is not null, the
         * resulting tree should be the plus child of its parent, ignored if
         * parentTree is null
         * @param leafFromInstance if true, the leaf node comes from the
         * instance tree ({@code tree1}) and the tree node comes from
         * the argument tree ({@code tree2})
         * @return the BSP tree resulting from the merging (may be one of
         * the arguments)
         */
        BSPTree&lt;S&gt; merge(BSPTree&lt;S&gt; leaf, BSPTree&lt;S&gt; tree, BSPTree&lt;S&gt; parentTree,
                         boolean isPlusChild, boolean leafFromInstance);

    }

    /** This interface handles the corner cases when an internal node cut sub-hyperplane vanishes.
     * &lt;p&gt;
     * Such cases happens for example when a cut sub-hyperplane is inserted into
     * another tree (during a merge operation), and is split in several parts,
     * some of which becomes smaller than the tolerance. The corresponding node
     * as then no cut sub-hyperplane anymore, but does have children. This interface
     * specifies how to handle this situation.
     * setting
     * &lt;/p&gt;
     * @since 3.4
     */
    public interface VanishingCutHandler&lt;S extends Space&gt; {

        /** Fix a node with both vanished cut and children.
         * @param node node to fix
         * @return fixed node
         */
        BSPTree&lt;S&gt; fixNode(BSPTree&lt;S&gt; node);

    }

    /** Split a BSP tree by an external sub-hyperplane.
     * &lt;p&gt;Split a tree in two halves, on each side of the
     * sub-hyperplane. The instance is not modified.&lt;/p&gt;
     * &lt;p&gt;The tree returned is not upward-consistent: despite all of its
     * sub-trees cut sub-hyperplanes (including its own cut
     * sub-hyperplane) are bounded to the current cell, it is &lt;em&gt;not&lt;/em&gt;
     * attached to any parent tree yet. This tree is intended to be
     * later inserted into an higher level tree.&lt;/p&gt;
     * &lt;p&gt;The algorithm used here is the one given in Naylor, Amanatides
     * and Thibault paper (section III, Binary Partitioning of a BSP
     * Tree).&lt;/p&gt;
     * @param sub partitioning sub-hyperplane, must be already clipped
     * to the convex region represented by the instance, will be used as
     * the cut sub-hyperplane of the returned tree
     * @return a tree having the specified sub-hyperplane as its cut
     * sub-hyperplane, the two parts of the split instance as its two
     * sub-trees and a null parent
     */
    public BSPTree&lt;S&gt; split(final SubHyperplane&lt;S&gt; sub) {

<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (cut == null) {</span>
<span class="fc" id="L572">            return new BSPTree&lt;S&gt;(sub, copySelf(), new BSPTree&lt;S&gt;(attribute), null);</span>
        }

<span class="fc" id="L575">        final Hyperplane&lt;S&gt; cHyperplane = cut.getHyperplane();</span>
<span class="fc" id="L576">        final Hyperplane&lt;S&gt; sHyperplane = sub.getHyperplane();</span>
<span class="fc bfc" id="L577" title="All 4 branches covered.">        switch (sub.side(cHyperplane)) {</span>
        case PLUS :
        { // the partitioning sub-hyperplane is entirely in the plus sub-tree
<span class="fc" id="L580">            final BSPTree&lt;S&gt; split = plus.split(sub);</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">            if (cut.side(sHyperplane) == Side.PLUS) {</span>
<span class="fc" id="L582">                split.plus =</span>
<span class="fc" id="L583">                    new BSPTree&lt;S&gt;(cut.copySelf(), split.plus, minus.copySelf(), attribute);</span>
<span class="fc" id="L584">                split.plus.condense();</span>
<span class="fc" id="L585">                split.plus.parent = split;</span>
<span class="fc" id="L586">            } else {</span>
<span class="fc" id="L587">                split.minus =</span>
<span class="fc" id="L588">                    new BSPTree&lt;S&gt;(cut.copySelf(), split.minus, minus.copySelf(), attribute);</span>
<span class="fc" id="L589">                split.minus.condense();</span>
<span class="fc" id="L590">                split.minus.parent = split;</span>
            }
<span class="fc" id="L592">            return split;</span>
        }
        case MINUS :
        { // the partitioning sub-hyperplane is entirely in the minus sub-tree
<span class="fc" id="L596">            final BSPTree&lt;S&gt; split = minus.split(sub);</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">            if (cut.side(sHyperplane) == Side.PLUS) {</span>
<span class="fc" id="L598">                split.plus =</span>
<span class="fc" id="L599">                    new BSPTree&lt;S&gt;(cut.copySelf(), plus.copySelf(), split.plus, attribute);</span>
<span class="fc" id="L600">                split.plus.condense();</span>
<span class="fc" id="L601">                split.plus.parent = split;</span>
<span class="fc" id="L602">            } else {</span>
<span class="fc" id="L603">                split.minus =</span>
<span class="fc" id="L604">                    new BSPTree&lt;S&gt;(cut.copySelf(), plus.copySelf(), split.minus, attribute);</span>
<span class="fc" id="L605">                split.minus.condense();</span>
<span class="fc" id="L606">                split.minus.parent = split;</span>
            }
<span class="fc" id="L608">            return split;</span>
        }
        case BOTH :
        {
<span class="fc" id="L612">            final SubHyperplane.SplitSubHyperplane&lt;S&gt; cutParts = cut.split(sHyperplane);</span>
<span class="fc" id="L613">            final SubHyperplane.SplitSubHyperplane&lt;S&gt; subParts = sub.split(cHyperplane);</span>
<span class="fc" id="L614">            final BSPTree&lt;S&gt; split =</span>
<span class="fc" id="L615">                new BSPTree&lt;S&gt;(sub, plus.split(subParts.getPlus()), minus.split(subParts.getMinus()),</span>
<span class="fc" id="L616">                               null);</span>
<span class="fc" id="L617">            split.plus.cut          = cutParts.getPlus();</span>
<span class="fc" id="L618">            split.minus.cut         = cutParts.getMinus();</span>
<span class="fc" id="L619">            final BSPTree&lt;S&gt; tmp    = split.plus.minus;</span>
<span class="fc" id="L620">            split.plus.minus        = split.minus.plus;</span>
<span class="fc" id="L621">            split.plus.minus.parent = split.plus;</span>
<span class="fc" id="L622">            split.minus.plus        = tmp;</span>
<span class="fc" id="L623">            split.minus.plus.parent = split.minus;</span>
<span class="fc" id="L624">            split.plus.condense();</span>
<span class="fc" id="L625">            split.minus.condense();</span>
<span class="fc" id="L626">            return split;</span>
        }
        default :
<span class="fc bfc" id="L629" title="All 2 branches covered.">            return cHyperplane.sameOrientationAs(sHyperplane) ?</span>
<span class="fc" id="L630">                   new BSPTree&lt;S&gt;(sub, plus.copySelf(),  minus.copySelf(), attribute) :</span>
<span class="fc" id="L631">                   new BSPTree&lt;S&gt;(sub, minus.copySelf(), plus.copySelf(),  attribute);</span>
        }

    }

    /** Insert the instance into another tree.
     * &lt;p&gt;The instance itself is modified so its former parent should
     * not be used anymore.&lt;/p&gt;
     * @param parentTree parent tree to connect to (may be null)
     * @param isPlusChild if true and if parentTree is not null, the
     * resulting tree should be the plus child of its parent, ignored if
     * parentTree is null
     * @see LeafMerger
     * @deprecated as of 3.4, replaced with {@link #insertInTree(BSPTree, boolean, VanishingCutHandler)}
     */
    @Deprecated
    public void insertInTree(final BSPTree&lt;S&gt; parentTree, final boolean isPlusChild) {
<span class="nc" id="L648">        insertInTree(parentTree, isPlusChild, new VanishingCutHandler&lt;S&gt;() {</span>
            /** {@inheritDoc} */
            public BSPTree&lt;S&gt; fixNode(BSPTree&lt;S&gt; node) {
                // the cut should not be null
<span class="nc" id="L652">                throw new MathIllegalStateException(LocalizedFormats.NULL_NOT_ALLOWED);</span>
            }
        });
<span class="nc" id="L655">    }</span>

    /** Insert the instance into another tree.
     * &lt;p&gt;The instance itself is modified so its former parent should
     * not be used anymore.&lt;/p&gt;
     * @param parentTree parent tree to connect to (may be null)
     * @param isPlusChild if true and if parentTree is not null, the
     * resulting tree should be the plus child of its parent, ignored if
     * parentTree is null
     * @param vanishingHandler handler to use for handling very rare corner
     * cases of vanishing cut sub-hyperplanes in internal nodes during merging
     * @see LeafMerger
     * @since 3.4
     */
    public void insertInTree(final BSPTree&lt;S&gt; parentTree, final boolean isPlusChild,
                             final VanishingCutHandler&lt;S&gt; vanishingHandler) {

        // set up parent/child links
<span class="fc" id="L673">        parent = parentTree;</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">        if (parentTree != null) {</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (isPlusChild) {</span>
<span class="fc" id="L676">                parentTree.plus = this;</span>
<span class="fc" id="L677">            } else {</span>
<span class="fc" id="L678">                parentTree.minus = this;</span>
            }
        }

        // make sure the inserted tree lies in the cell defined by its parent nodes
<span class="fc bfc" id="L683" title="All 2 branches covered.">        if (cut != null) {</span>

            // explore the parent nodes from here towards tree root
<span class="fc bfc" id="L686" title="All 2 branches covered.">            for (BSPTree&lt;S&gt; tree = this; tree.parent != null; tree = tree.parent) {</span>

                // this is an hyperplane of some parent node
<span class="fc" id="L689">                final Hyperplane&lt;S&gt; hyperplane = tree.parent.cut.getHyperplane();</span>

                // chop off the parts of the inserted tree that extend
                // on the wrong side of this parent hyperplane
<span class="fc bfc" id="L693" title="All 2 branches covered.">                if (tree == tree.parent.plus) {</span>
<span class="fc" id="L694">                    cut = cut.split(hyperplane).getPlus();</span>
<span class="fc" id="L695">                    plus.chopOffMinus(hyperplane, vanishingHandler);</span>
<span class="fc" id="L696">                    minus.chopOffMinus(hyperplane, vanishingHandler);</span>
<span class="fc" id="L697">                } else {</span>
<span class="fc" id="L698">                    cut = cut.split(hyperplane).getMinus();</span>
<span class="fc" id="L699">                    plus.chopOffPlus(hyperplane, vanishingHandler);</span>
<span class="fc" id="L700">                    minus.chopOffPlus(hyperplane, vanishingHandler);</span>
                }

<span class="pc bpc" id="L703" title="1 of 2 branches missed.">                if (cut == null) {</span>
                    // the cut sub-hyperplane has vanished
<span class="nc" id="L705">                    final BSPTree&lt;S&gt; fixed = vanishingHandler.fixNode(this);</span>
<span class="nc" id="L706">                    cut       = fixed.cut;</span>
<span class="nc" id="L707">                    plus      = fixed.plus;</span>
<span class="nc" id="L708">                    minus     = fixed.minus;</span>
<span class="nc" id="L709">                    attribute = fixed.attribute;</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">                    if (cut == null) {</span>
<span class="nc" id="L711">                        break;</span>
                    }
                }

            }

            // since we may have drop some parts of the inserted tree,
            // perform a condensation pass to keep the tree structure simple
<span class="fc" id="L719">            condense();</span>

        }

<span class="fc" id="L723">    }</span>

    /** Prune a tree around a cell.
     * &lt;p&gt;
     * This method can be used to extract a convex cell from a tree.
     * The original cell may either be a leaf node or an internal node.
     * If it is an internal node, it's subtree will be ignored (i.e. the
     * extracted cell will be a leaf node in all cases). The original
     * tree to which the original cell belongs is not touched at all,
     * a new independent tree will be built.
     * &lt;/p&gt;
     * @param cellAttribute attribute to set for the leaf node
     * corresponding to the initial instance cell
     * @param otherLeafsAttributes attribute to set for the other leaf
     * nodes
     * @param internalAttributes attribute to set for the internal nodes
     * @return a new tree (the original tree is left untouched) containing
     * a single branch with the cell as a leaf node, and other leaf nodes
     * as the remnants of the pruned branches
     * @since 3.3
     */
    public BSPTree&lt;S&gt; pruneAroundConvexCell(final Object cellAttribute,
                                            final Object otherLeafsAttributes,
                                            final Object internalAttributes) {

        // build the current cell leaf
<span class="fc" id="L749">        BSPTree&lt;S&gt; tree = new BSPTree&lt;S&gt;(cellAttribute);</span>

        // build the pruned tree bottom-up
<span class="fc bfc" id="L752" title="All 2 branches covered.">        for (BSPTree&lt;S&gt; current = this; current.parent != null; current = current.parent) {</span>
<span class="fc" id="L753">            final SubHyperplane&lt;S&gt; parentCut = current.parent.cut.copySelf();</span>
<span class="fc" id="L754">            final BSPTree&lt;S&gt;       sibling   = new BSPTree&lt;S&gt;(otherLeafsAttributes);</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">            if (current == current.parent.plus) {</span>
<span class="fc" id="L756">                tree = new BSPTree&lt;S&gt;(parentCut, tree, sibling, internalAttributes);</span>
<span class="fc" id="L757">            } else {</span>
<span class="fc" id="L758">                tree = new BSPTree&lt;S&gt;(parentCut, sibling, tree, internalAttributes);</span>
            }
        }

<span class="fc" id="L762">        return tree;</span>

    }

    /** Chop off parts of the tree.
     * &lt;p&gt;The instance is modified in place, all the parts that are on
     * the minus side of the chopping hyperplane are discarded, only the
     * parts on the plus side remain.&lt;/p&gt;
     * @param hyperplane chopping hyperplane
     * @param vanishingHandler handler to use for handling very rare corner
     * cases of vanishing cut sub-hyperplanes in internal nodes during merging
     */
    private void chopOffMinus(final Hyperplane&lt;S&gt; hyperplane, final VanishingCutHandler&lt;S&gt; vanishingHandler) {
<span class="fc bfc" id="L775" title="All 2 branches covered.">        if (cut != null) {</span>

<span class="fc" id="L777">            cut = cut.split(hyperplane).getPlus();</span>
<span class="fc" id="L778">            plus.chopOffMinus(hyperplane, vanishingHandler);</span>
<span class="fc" id="L779">            minus.chopOffMinus(hyperplane, vanishingHandler);</span>

<span class="pc bpc" id="L781" title="1 of 2 branches missed.">            if (cut == null) {</span>
                // the cut sub-hyperplane has vanished
<span class="nc" id="L783">                final BSPTree&lt;S&gt; fixed = vanishingHandler.fixNode(this);</span>
<span class="nc" id="L784">                cut       = fixed.cut;</span>
<span class="nc" id="L785">                plus      = fixed.plus;</span>
<span class="nc" id="L786">                minus     = fixed.minus;</span>
<span class="nc" id="L787">                attribute = fixed.attribute;</span>
            }

        }
<span class="fc" id="L791">    }</span>

    /** Chop off parts of the tree.
     * &lt;p&gt;The instance is modified in place, all the parts that are on
     * the plus side of the chopping hyperplane are discarded, only the
     * parts on the minus side remain.&lt;/p&gt;
     * @param hyperplane chopping hyperplane
     * @param vanishingHandler handler to use for handling very rare corner
     * cases of vanishing cut sub-hyperplanes in internal nodes during merging
     */
    private void chopOffPlus(final Hyperplane&lt;S&gt; hyperplane, final VanishingCutHandler&lt;S&gt; vanishingHandler) {
<span class="fc bfc" id="L802" title="All 2 branches covered.">        if (cut != null) {</span>

<span class="fc" id="L804">            cut = cut.split(hyperplane).getMinus();</span>
<span class="fc" id="L805">            plus.chopOffPlus(hyperplane, vanishingHandler);</span>
<span class="fc" id="L806">            minus.chopOffPlus(hyperplane, vanishingHandler);</span>

<span class="fc bfc" id="L808" title="All 2 branches covered.">            if (cut == null) {</span>
                // the cut sub-hyperplane has vanished
<span class="fc" id="L810">                final BSPTree&lt;S&gt; fixed = vanishingHandler.fixNode(this);</span>
<span class="fc" id="L811">                cut       = fixed.cut;</span>
<span class="fc" id="L812">                plus      = fixed.plus;</span>
<span class="fc" id="L813">                minus     = fixed.minus;</span>
<span class="fc" id="L814">                attribute = fixed.attribute;</span>
            }

        }
<span class="fc" id="L818">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>